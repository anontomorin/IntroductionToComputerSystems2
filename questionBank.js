// 完整题库数据（包含所有252道题，按章节分类）
const questionBank = [
    // 第一章 计算机系统概述（20题）
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关对摩尔定律的描述中，错误的是 ()。",
        options: [
            "A. 每 18 个月，集成电路芯片上集成的晶体管数将翻一番",
            "B. 每 18 个月，集成电路芯片的速度将提高一倍",
            "C. 每 18 个月，集成电路芯片的价格将降低一半",
            "D. 集成电路技术一直会遵循摩尔定律发展下去"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "从计算机的主要元器件来看，计算机发展所经历的过程为 ()。",
        options: [
            "A. 晶体管、电子管、SSI、MSI、LSI、ULSI、VLSI",
            "B. 电子管、晶体管、SSI、MSI、LSI、VLSI、ULSI",
            "C. 电子管、晶体管、LSI、MSI、SSI、VLSI、ULSI",
            "D. 晶体管、电子管、MSI、SSI、LSI、ULSI、VLSI"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "一个完整的计算机系统包括硬件和软件。软件又分为 ()。",
        options: [
            "A. 操作系统和语言处理程序",
            "B. 系统软件和应用软件",
            "C. 操作系统和高级语言",
            "D. 低级语言程序和高级语言程序"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下给出的软件中，属于应用软件的是 ()。",
        options: [
            "A. 汇编程序",
            "B. 编译程序",
            "C. 操作系统",
            "D. 办公软件（注：原题选项 D 为具体应用软件，按原文保留）"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下给出的软件中，属于系统软件的是 ()。",
        options: [
            "A. Windows XP",
            "B. MS Word",
            "C. 金山词霸",
            "D. RealPlayer"
        ],
        answer: "A"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关指令集体系结构的说法中，错误的是 ()。",
        options: [
            "A. 指令集体系结构位于计算机软件和硬件的交界面上",
            "B. 指令集体系结构是指低级语言程序员所看到的概念结构和功能特性",
            "C. 程序员可见寄存器的长度、功能与编号不属于指令集体系结构的内容",
            "D. 指令集体系结构的英文缩写是 ISA"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "计算机系统采用层次化结构，从最上面的应用层到最下面的硬件层，其层次化构成为 ()。",
        options: [
            "A. 高级语言虚拟机 - 操作系统虚拟机 - 汇编语言虚拟机 - 机器语言机器",
            "B. 高级语言虚拟机 - 汇编语言虚拟机 - 机器语言机器 - 操作系统虚拟机",
            "C. 高级语言虚拟机 - 汇编语言虚拟机 - 操作系统虚拟机 - 机器语言机器",
            "D. 操作系统虚拟机 - 高级语言虚拟机 - 汇编语言虚拟机 - 机器语言机器"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关程序编写和执行方面的叙述中，错误的是 ()。",
        options: [
            "A. 可用高级语言和低级语言编写出功能等价的程序",
            "B. 高级语言和汇编语言源程序都不能在机器上直接执行",
            "C. 编译程序员必须了解机器结构和指令系统",
            "D. 汇编语言是一种与机器结构无关的编程语言"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "冯・诺依曼计算机中，CPU 区分从存储器取出的是指令还是数据的依据是 ()。",
        options: [
            "A. 指令译码结果的不同",
            "B. 指令和数据的寻址方式的不同",
            "C. 指令和数据的访问阶段的不同",
            "D. 指令和数据所在的存储单元的不同"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关冯・诺依曼计算机结构中指令和数据表示形式的叙述中，正确的是 ()。",
        options: [
            "A. 指令和数据可以从形式上加以区分",
            "B. 指令以二进制形式存放，数据以十进制形式存放",
            "C. 指令和数据都以二进制形式存放",
            "D. 指令和数据都以十进制形式存放"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关计算机中指令和数据存放位置的叙述中，正确的是 ()。",
        options: [
            "A. 指令存放在内存，数据存放在外存",
            "B. 指令和数据任何时候都存放在内存",
            "C. 指令和数据任何时候都存放在外存",
            "D. 程序被启动后，其指令和数据被装入内存"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "冯・诺依曼计算机工作方式的基本特点是 ()。",
        options: [
            "A. 程序一边被输入计算机一边被执行",
            "B. 程序直接从磁盘读到 CPU 执行",
            "C. 按地址访问指令并自动按序执行程序",
            "D. 程序自动执行而数据手工输入"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关冯・诺依曼计算机结构的叙述中，错误的是 ()。",
        options: [
            "A. 计算机由运算器、控制器、存储器和输入 / 输出设备组成",
            "B. 程序由指令和数据构成，存放在存储器中",
            "C. 指令由操作码和地址码两部分组成",
            "D. 指令按地址访问，所有数据在指令中直接给出"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关计算机各部件功能的叙述中，错误的是 ()。",
        options: [
            "A. 运算器用来完成算术运算",
            "B. 存储器用来存放指令和数据",
            "C. 控制器通过执行指令来控制整个机器的运行",
            "D. 输入 / 输出设备用来完成用户和计算机之间的信息交换"
        ],
        answer: "A"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下给出了改善计算机性能的 4 种措施：①用更快的处理器来替换原来的慢速处理器②增加同类处理器个数，使得不同的处理器同时执行程序③优化编译生成的代码使得程序执行的总时钟周期数减少④减少指令执行过程中访问内存的时间对于某个特定的程序，以上措施中，能缩短其执行时间的措施是 ()。",
        options: [
            "A. 仅①和②和③",
            "B. 仅①和②和④",
            "C. 仅①和③和④",
            "D. 全部"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "若某典型基准测试程序在机器 A 上运行时需要 20s，而在机器 B 上的运行时间是 16s，则相对来说，下面给出的结论中，正确的是 ()。",
        options: [
            "A. 所有程序在机器 A 上都比在机器 B 上运行速度慢",
            "B. 机器 B 的速度是机器 A 的 1.25 倍",
            "C. 机器 A 的速度是机器 B 的 1.25 倍",
            "D. 机器 A 比机器 B 慢 1.25 倍"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "已知计算机 A 的时钟频率为 800MHz，假定某程序在计算机 A 上运行需要 12s。现在硬件设计人员想设计计算机 B，希望该程序在 B 上的运行时间能缩短为 8s，使用新技术后可使 B 的时钟频率大幅度提高，但在 B 上运行该程序所需的时钟周期数为在 A 上的 1.5 倍。那么，机器 B 的时钟频率至少应为多少才能达到所希望的要求？()",
        options: [
            "A. 800MHz",
            "B. 1.2GHz",
            "C. 1.5GHz",
            "D. 1.8GHz"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "假设同一套指令集用不同的方法设计了两种计算机 A 和 B。机器 A 的时钟周期为 1.2ns，机器 B 的时钟周期为 2ns。某个程序在机器 A 上运行时的 CPI 为 2，在 B 上的 CPI 为 1，则对于该程序来说，机器 A 和机器 B 之间的速度关系为 ()。",
        options: [
            "A. 机器 A 比机器 B 快 1.2 倍",
            "B. 机器 B 比机器 A 快 1.2 倍",
            "C. 机器 A 的速度是机器 B 的 12 倍",
            "D. 机器 B 的速度是机器 A 的 1.2 倍"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "假定编译器对高级语言的某条语句可以编译生成两种不同的指令序列，A、B 和 C 三类指令的 CPI 和两种不同序列中所含的三类指令的条数见表 1.1。则以下哪个结论是错误的？()",
        options: [
            "A. 序列一比序列二少 1 条指令",
            "B. 序列一比序列二的执行速度快",
            "C. 序列一的总时钟周期数比序列二多 1 个",
            "D. 序列一的 CPI 比序列二的 CPI 大"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "假定用不同的编译器对同一个程序进行编译生成不同的目标代码指令序列，A、B 和 C 三类指令的 CPI 和两种不同指令序列中所含的三类指令条数见表 1.2。两个指令序列都在时钟周期为 2ns 的机器上运行。根据计算得到其 MIPS 指标和执行速度两方面的结论为 ()。",
        options: [
            "A. 序列一的 MIPS 数比序列二多 50，序列一的执行速度也比序列二快 10s",
            "B. 序列二的 MIPS 数比序列一多 50，但序列一的执行速度比序列二快 10s",
            "C. 序列一的 MIPS 数比序列一多 100，序列一的执行速度也比序列二快 20s",
            "D. 序列二的 MIPS 数比序列一多 100，但序列一的执行速度比序列二快 20s"
        ],
        answer: "B"
    },
    // 第二章 数据的机器级表示与处理（58题）
 {
        chapter: "第二章 数据的机器级表示与处理",
        question: "计算机中的所有信息都以二进制表示的原因是 ()。",
        options: [
            "A. 信息处理方便",
            "B. 运算速度快",
            "C. 节约元器件",
            "D. 物理器件特性所致"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "引入八进制和十六进制的目的是 ()。",
        options: [
            "A. 节约元件",
            "B. 实现方便",
            "C. 可以表示更大范围的数",
            "D. 用于等价地表示二进制，便于阅读和书写"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若二进制数为 10110100B，其对应的十六进制数为 ()。",
        options: [
            "A. 6CH",
            "B. B4H",
            "C. 5CH",
            "D. 63H"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下给出的各种进位计数制的数中，最小的数为 ()。",
        options: [
            "A. (10010110)₂",
            "B. (63)₈",
            "C. (1001 0110) BCD",
            "D. (2F)₁₆"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下给出的各种进位计数制的数中，最小的数为 ()。",
        options: [
            "A. (1110 0101)₂",
            "B. (93)₁₀",
            "C. (1001 0010) BCD",
            "D. (5A)₁₆"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "负零的补码表示为 ()。",
        options: [
            "A. 100...00",
            "B. 000...00",
            "C. 011...11",
            "D. 111...11"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "[X] 补 = X₀・X₁X₂…Xₙ（n 为整数），它的模是 ()。",
        options: [
            "A. 2ⁿ⁻¹",
            "B. 2ⁿ",
            "C. 1",
            "D. 2"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "[X] 补 = X₀X₁X₂…Xₙ（n 为整数，X₀为符号位），它的模是 ()。",
        options: [
            "A. 2ⁿ⁺¹",
            "B. 2ⁿ",
            "C. 2ⁿ⁺¹",
            "D. 2ⁿ⁻¹"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下编码中，零的表示形式是唯一的编码是 ()。",
        options: [
            "A. 反码",
            "B. 原码",
            "C. 补码",
            "D. 原码和补码"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下有关补码和移码（偏置常数为 2ⁿ⁻¹）关系的叙述中，错误的是 ()。",
        options: [
            "A. 相同位数的补码和移码表示具有相同的表数范围",
            "B. 零的补码和移码表示相同",
            "C. 同一个数的补码和移码表示，其数值部分相同，而符号相反",
            "D. 一般用移码表示浮点数的阶，而用补码表示定点整数"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下是一些关于编码表示特点的叙述：①零的表示是唯一的。②符号位可以和数值部分一起参加运算。③和其真值的对应关系简单、直观。④减法可用加法来实现。其中哪些选项是补码表示的特点？()",
        options: [
            "A. 仅①和②",
            "B. 仅①和③",
            "C. 仅①和②和③",
            "D. 仅①和②和④"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定某数 X=-01001010B，在计算机内部的表示为 10110110B，则该数所用的编码方法是 ()。",
        options: [
            "A. 原码",
            "B. 反码",
            "C. 补码",
            "D. 移码"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设寄存器位数为 8 位，机器数采用补码形式（含一位符号位），则十进制数 - 26 存放在寄存器中的内容为 ()。",
        options: [
            "A. 26H",
            "B. 9BH",
            "C. E6H",
            "D. 5AH"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "-1029 的 16 位补码用十六进制表示为 ()。",
        options: [
            "A. 0405H",
            "B. 7BFBH",
            "C. 8405H",
            "D. FBFBH"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "考虑以下 C 语言代码：short si= -8196; unsigned short usi=si; 执行上述程序段后，usi 的值是 ()。",
        options: [
            "A. 8196",
            "B. 34572",
            "C. 57339",
            "D. 57340"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若 [X] 原 = 1.x₁x₂x₃x₄，其中，小数点前面一位是符号位，符号位为 1 时表示负数。当满足 () 时，X>-1/2 成立。",
        options: [
            "A. x₁必须为 1，x₂、x₃、x₄至少有一个为 1",
            "B. x₁必须为 1，x₂、x₃、x₄任意",
            "C. x₁必须为 0，x₂、x₃、x₄至少有一个为 1",
            "D. x₁必须为 0，x₂、x₃、x₄任意"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设 X=-1011，则 8 位补码 [X] 补为 ()。",
        options: [
            "A. 1000 0101",
            "B. 1000 1011",
            "C. 1111 0101",
            "D. 1111 1011"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "16 位无符号数所能表示的数值范围是 ()。",
        options: [
            "A. 0~(2¹⁶-1)",
            "B. 0~(2¹⁵-1)",
            "C. 0~2¹⁶",
            "D. 0~2¹⁵"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "16 位补码整数所能表示的范围是 ()。",
        options: [
            "A. -2¹⁵~+(2¹⁵-1)",
            "B. -(2¹⁵-1)~+(2¹⁵-1)",
            "C. -2¹⁶~+(2¹⁶-1)",
            "D. -(2¹⁶-1)~+(2¹⁶-1)"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若浮点数尾数用补码表示，则下列数中为规格化尾数形式的是 ()。",
        options: [
            "A. 1.110 0000",
            "B. 0.011 1000",
            "C. 0.010 1000",
            "D. 1.000 1000"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若浮点数尾数用原码表示，则下列数中为规格化尾数形式的是 ()。",
        options: [
            "A. 1.110 0000",
            "B. 0.011 1000",
            "C. 0.010 1000",
            "D. 1.000 1000"
        ],
        answer: "A"
    },
    // 补充的第二章题目（第22-58题）
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "已知 X 的补码为 10110100，其原码为 ()。",
        options: [
            "A. 11001100",
            "B. 11001011",
            "C. 10110100",
            "D. 01001100"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "十进制数 27 的 8 位原码、反码、补码表示，正确的是 ()。",
        options: [
            "A. 00011011、00011011、00011011",
            "B. 00011011、11100100、11100101",
            "C. 10011011、11100100、11100101",
            "D. 00011011、00011011、11100101"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "8 位补码所能表示的十进制整数范围是 ()。",
        options: [
            "A. -127 ~ +127",
            "B. -128 ~ +127",
            "C. -128 ~ +128",
            "D. -127 ~ +128"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "两个补码数相加，采用 1 位符号位，当 () 时表示结果溢出。",
        options: [
            "A. 符号位有进位",
            "B. 符号位进位和最高数值位进位异或结果为 1",
            "C. 最高数值位有进位",
            "D. 符号位进位和最高数值位进位异或结果为 0"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设机器数采用补码表示（含 1 位符号位），若寄存器内容为 9BH，则对应的十进制数为 ()。",
        options: [
            "A. -101",
            "B. -27",
            "C. -25",
            "D. 155"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IEEE 754 标准中，32 位单精度浮点数的符号位 1 位，阶码 8 位，尾数 23 位，则其所能表示的最大正数为 ()。",
        options: [
            "A. (+1 - 2⁻²³) × 2¹²⁷",
            "B. (+1 - 2⁻²³) × 2¹²⁸",
            "C. (+1 - 2⁻²³) × 2⁻¹²⁷",
            "D. 2¹²⁷ - 2⁻²³"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IEEE 754 标准中，32 位单精度浮点数的阶码采用的编码方式是 ()。",
        options: [
            "A. 原码",
            "B. 补码",
            "C. 移码",
            "D. 反码"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "十进制数 -12 的 8 位移码表示为 ()。",
        options: [
            "A. 01110100",
            "B. 11110100",
            "C. 10001100",
            "D. 00001100"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若某数的真值为 -0.1010B，在计算机中表示为 1.0110B，则该数所用的编码方法是 ()。",
        options: [
            "A. 原码",
            "B. 补码",
            "C. 反码",
            "D. 移码"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "BCD 码中，每一位十进制数用 () 位二进制数表示。",
        options: [
            "A. 2",
            "B. 3",
            "C. 4",
            "D. 8"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于 ASCII 码的叙述中，错误的是 ()。",
        options: [
            "A. ASCII 码是美国信息交换标准代码的简称",
            "B. ASCII 码包含了大小写英文字母、数字、标点符号等字符",
            "C. ASCII 码用 7 位二进制数表示，可表示 128 个字符",
            "D. 扩展 ASCII 码用 8 位二进制数表示，可表示 256 个字符，且在所有系统中都兼容"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "定点数表示中，定点小数的小数点位置固定在 ()。",
        options: [
            "A. 符号位之后",
            "B. 最高数值位之后",
            "C. 最低数值位之后",
            "D. 符号位之前"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设定点整数的字长为 8 位（含 1 位符号位），采用原码表示，则其能表示的最大正数为 ()。",
        options: [
            "A. 2⁷ - 1",
            "B. 2⁷",
            "C. 2⁸ - 1",
            "D. 2⁸"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "浮点数的表示范围主要由 () 决定，精度主要由 () 决定。",
        options: [
            "A. 尾数、阶码",
            "B. 阶码、尾数",
            "C. 符号位、尾数",
            "D. 阶码、符号位"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "已知两个补码分别为 [X]补 = 01010100，[Y]补 = 10111000，则 [X+Y]补 为 ()。",
        options: [
            "A. 00001100",
            "B. 11110100",
            "C. 00001100（溢出）",
            "D. 11110100（溢出）"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "已知 [X]补 = 11011010，[Y]补 = 10110000，则 [X-Y]补 为 ()。",
        options: [
            "A. 00101010",
            "B. 11010110",
            "C. 00101010（溢出）",
            "D. 11010110（溢出）"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "将十进制数 0.625 转换为二进制数，结果为 ()。",
        options: [
            "A. 0.101",
            "B. 0.110",
            "C. 0.011",
            "D. 0.111"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "将八进制数 (75.4)₈ 转换为二进制数，结果为 ()。",
        options: [
            "A. 111101.100",
            "B. 111101.010",
            "C. 101111.100",
            "D. 101111.010"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "将十六进制数 (A7.8)₁₆ 转换为十进制数，结果为 ()。",
        options: [
            "A. 167.5",
            "B. 177.8",
            "C. 167.8",
            "D. 177.5"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于定点数和浮点数的叙述中，错误的是 ()。",
        options: [
            "A. 定点数表示法的优点是运算简单，缺点是表示范围小",
            "B. 浮点数表示法的优点是表示范围大，缺点是运算复杂",
            "C. 定点数的小数点位置固定，浮点数的小数点位置不固定",
            "D. 定点数和浮点数的符号位都只能用 0 表示正数，1 表示负数"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若浮点数的阶码用 4 位移码表示，偏置常数为 8，则阶码 -3 的移码表示为 ()。",
        options: [
            "A. 0101",
            "B. 1011",
            "C. 0110",
            "D. 1010"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "在定点小数的补码表示中，能表示的最小负数为 ()。",
        options: [
            "A. -1",
            "B. -(1 - 2⁻ⁿ)",
            "C. -2⁻ⁿ",
            "D. -2ⁿ"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "两个定点数相乘，乘积的位数是原操作数位数的 () 倍（不考虑符号位）。",
        options: [
            "A. 1",
            "B. 2",
            "C. 3",
            "D. 4"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "定点除法运算中，为避免溢出，要求被除数的绝对值 () 除数的绝对值。",
        options: [
            "A. 大于",
            "B. 大于等于",
            "C. 小于",
            "D. 小于等于"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于浮点数加减运算的步骤，正确的顺序是 ()。①尾数加减 ②结果规格化 ③舍入处理 ④阶码对齐 ⑤溢出判断",
        options: [
            "A. ④①②③⑤",
            "B. ④①③②⑤",
            "C. ①④②③⑤",
            "D. ①④③②⑤"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "ASCII 码中，字符 '0' 的编码值为 48（十进制），则字符 '9' 的 ASCII 码值为 ()（十进制）。",
        options: [
            "A. 56",
            "B. 57",
            "C. 58",
            "D. 59"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若某浮点数的尾数为 1.00101（补码表示，规格化），则其对应的真值为 ()。",
        options: [
            "A. -0.11011",
            "B. -0.00101",
            "C. +0.00101",
            "D. +0.11011"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设 8 位二进制数的原码为 10010101，则其对应的反码为 ()。",
        options: [
            "A. 11101010",
            "B. 11101011",
            "C. 01101010",
            "D. 01101011"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于补码乘法的叙述中，正确的是 ()。",
        options: [
            "A. 补码乘法运算时，符号位和数值位分开运算",
            "B. 补码乘法的结果无需修正",
            "C. 补码乘法可以通过加法和移位实现",
            "D. 补码乘法的运算规则与原码乘法完全相同"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IEEE 754 标准中，32 位单精度浮点数的阶码偏置常数为 ()。",
        options: [
            "A. 127",
            "B. 128",
            "C. 255",
            "D. 256"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "十进制数 127 的 8 位补码表示为 ()。",
        options: [
            "A. 01111111",
            "B. 10000000",
            "C. 11111111",
            "D. 00000000"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "十进制数 -128 的 8 位补码表示为 ()。",
        options: [
            "A. 10000000",
            "B. 11111111",
            "C. 00000000",
            "D. 01111111"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若 [X]反 = 11101010，则 X 的真值为 ()。",
        options: [
            "A. -0010101",
            "B. -0010101",
            "C. -00101011",
            "D. -0010100"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于 BCD 码的叙述中，正确的是 ()。",
        options: [
            "A. BCD 码是一种二进制数",
            "B. 8421 BCD 码中，每一位的权值分别为 8、4、2、1",
            "C. BCD 码可以直接进行二进制运算",
            "D. 8421 BCD 码能表示 0~15 之间的所有数"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "浮点数进行舍入处理时，若采用“朝零舍入”方式，则对于尾数超出规定位数的部分，处理方式为 ()。",
        options: [
            "A. 直接舍去",
            "B. 进 1",
            "C. 看最高位，1 则进 1，0 则舍去",
            "D. 凑偶数"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设字长为 32 位的定点整数，采用补码表示，则其能表示的最小负数为 ()。",
        options: [
            "A. -2³¹",
            "B. -2³¹ + 1",
            "C. -2³⁰",
            "D. -2³⁰ + 1"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "两个 8 位补码数 01001001 和 10110110 相加，结果的符号位为 ()，是否溢出？()",
        options: [
            "A. 0，无溢出",
            "B. 1，无溢出",
            "C. 0，有溢出",
            "D. 1，有溢出"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于移码的叙述中，正确的是 ()。",
        options: [
            "A. 移码的符号位与补码相反，数值位相同",
            "B. 移码只能表示正数",
            "C. 移码的零有两种表示形式",
            "D. 移码的表示范围与补码不同"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "将二进制数 1101101.101 转换为十进制数，结果为 ()。",
        options: [
            "A. 109.625",
            "B. 109.5",
            "C. 107.625",
            "D. 107.5"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "在浮点数的规格化处理中，若尾数用补码表示，当尾数为 1.0100000 时，需要进行的操作是 ()。",
        options: [
            "A. 左规，阶码减 1",
            "B. 左规，阶码加 1",
            "C. 右规，阶码减 1",
            "D. 右规，阶码加 1"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "ASCII 码采用 7 位编码时，可表示的字符数为 ()。",
        options: [
            "A. 64",
            "B. 128",
            "C. 256",
            "D. 512"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "已知 [X]补 = 00110101，[Y]补 = 11001011，则 X+Y 的真值为 ()。",
        options: [
            "A. 0",
            "B. 1",
            "C. -1",
            "D. 2"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IEEE754 标准提供了以下 4 种舍入模式，其中平均误差最小的是 ()。",
        options: [
            "A. 就近舍入 (中间值时强迫为偶数)",
            "B. 正向舍入 (即朝 +∞方向舍入)",
            "C. 负向舍入 (即朝 -∞方向舍入)",
            "D. 截断舍入 (即朝 0 方向舍入)"
        ],
        answer: "A"
    },


    // 第三章 程序的转换及机器级表示（78题）
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关指令的叙述中，错误的是 ()。",
        options: [
            "A. 机器指令是用二进制表示的一个 0/1 序列，CPU 能直接执行",
            "B. 汇编指令是机器指令的符号表示，CPU 能直接执行",
            "C. 伪指令是由若干条机器指令构成的一个指令序列，属于软件范畴",
            "D. 微指令是一条机器指令所包含的控制信号的组合，CPU 能直接执行"
        ],
        answer: "B"
    },
// 第三章 程序的转换及机器级表示（78题）   
   {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于指令格式的叙述中，正确的是 ()。",
        options: [
            "A. 指令格式就是指令字的二进制编码格式",
            "B. 指令格式中操作码字段表示指令的操作类型，地址码字段表示操作数地址",
            "C. 定长操作码指令格式不利于提高指令译码速度",
            "D. 变长操作码指令格式可以有效缩短指令长度，但会增加译码复杂度"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某机器指令字长为 16 位，操作码占 4 位，地址码占 12 位，若采用直接寻址方式，则该指令能访问的最大主存空间为 ()。",
        options: [
            "A. 4KB",
            "B. 8KB",
            "C. 12KB",
            "D. 16KB"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下寻址方式中，操作数的地址不需要通过计算就可以直接得到的是 ()。",
        options: [
            "A. 变址寻址",
            "B. 直接寻址",
            "C. 基址寻址",
            "D. 相对寻址"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "采用基址寻址的主要目的是 ()。",
        options: [
            "A. 扩大寻址空间",
            "B. 提高指令执行速度",
            "C. 实现程序的浮动装载",
            "D. 实现指令的并行执行"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "相对寻址方式中，操作数的有效地址是 ()。",
        options: [
            "A. 基址寄存器内容加上形式地址（位移量）",
            "B. 程序计数器内容加上形式地址（位移量）",
            "C. 变址寄存器内容加上形式地址（位移量）",
            "D. 通用寄存器内容加上形式地址（位移量）"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于堆栈寻址的叙述中，正确的是 ()。",
        options: [
            "A. 堆栈寻址的操作数在堆栈中，堆栈指针指向栈顶元素",
            "B. 堆栈寻址不需要指令给出操作数地址",
            "C. 堆栈只能采用“后进先出”的访问方式",
            "D. 堆栈寻址的指令执行速度比寄存器寻址快"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某指令采用寄存器间接寻址方式，其操作数位于 ()。",
        options: [
            "A. 寄存器中",
            "B. 主存单元中",
            "C. 堆栈中",
            "D. 程序计数器中"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下指令中，属于数据传送类指令的是 ()。",
        options: [
            "A. ADD R1, R2",
            "B. MOV R1, [R2]",
            "C. JMP 0x1000",
            "D. CMP R1, R2"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于指令系统的叙述中，错误的是 ()。",
        options: [
            "A. 指令系统是一台计算机所能执行的全部指令的集合",
            "B. 指令系统的复杂度与计算机的体系结构相关",
            "C. RISC 指令系统的指令条数少，指令格式简单",
            "D. CISC 指令系统的指令执行效率比 RISC 高"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "RISC 指令系统的特点不包括 ()。",
        options: [
            "A. 指令长度固定",
            "B. 大部分指令在一个时钟周期内完成",
            "C. 采用复杂的寻址方式",
            "D. 大量使用寄存器-寄存器操作"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "汇编程序的主要功能是 ()。",
        options: [
            "A. 将高级语言程序转换为机器语言程序",
            "B. 将汇编语言程序转换为机器语言程序",
            "C. 将机器语言程序转换为汇编语言程序",
            "D. 将高级语言程序转换为汇编语言程序"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于编译程序和解释程序的叙述中，正确的是 ()。",
        options: [
            "A. 编译程序生成目标程序，解释程序不生成目标程序",
            "B. 解释程序生成目标程序，编译程序不生成目标程序",
            "C. 编译程序和解释程序都生成目标程序",
            "D. 编译程序和解释程序都不生成目标程序"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "指令执行过程中，取指阶段的主要操作是 ()。",
        options: [
            "A. 根据程序计数器的内容到主存中取指令",
            "B. 根据指令的地址码到主存中取操作数",
            "C. 执行指令规定的运算操作",
            "D. 将运算结果写回指定的存储单元"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "CPU 中程序计数器（PC）的作用是 ()。",
        options: [
            "A. 存储当前执行指令的地址",
            "B. 存储下一条要执行指令的地址",
            "C. 存储当前执行指令的操作码",
            "D. 存储当前运算结果"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "CPU 中指令寄存器（IR）的作用是 ()。",
        options: [
            "A. 存储将要执行的下一条指令",
            "B. 存储当前正在执行的指令",
            "C. 存储指令执行的结果",
            "D. 存储指令的地址码部分"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于指令流水线的叙述中，正确的是 ()。",
        options: [
            "A. 指令流水线可以提高指令执行的并行度",
            "B. 指令流水线的级数越多，执行效率越高",
            "C. 流水线的吞吐率等于指令数除以流水线的级数",
            "D. 流水线的加速比等于流水线的级数"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "指令流水线中，数据冲突的主要原因是 ()。",
        options: [
            "A. 多条指令同时争用同一资源",
            "B. 后一条指令需要使用前一条指令的运算结果",
            "C. 指令的地址跳转导致流水线清空",
            "D. 不同指令的执行周期不同"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "解决流水线数据冲突的方法不包括 ()。",
        options: [
            "A. 数据旁路（转发）技术",
            "B. 指令重排",
            "C. 插入空操作（NOP）",
            "D. 增加流水线级数"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某指令流水线由 5 个阶段组成，每个阶段的执行时间分别为 2ns、3ns、2ns、3ns、2ns，则该流水线的最大吞吐率为 ()。",
        options: [
            "A. 1/2 ns⁻¹",
            "B. 1/3 ns⁻¹",
            "C. 1/12 ns⁻¹",
            "D. 5/12 ns⁻¹"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于存储器层次结构的叙述中，错误的是 ()。",
        options: [
            "A. 存储器层次结构基于“局部性原理”设计",
            "B. 缓存（Cache）的速度比主存快，容量比主存小",
            "C. 虚拟存储器的容量只受主存容量限制",
            "D. 寄存器的速度最快，容量最小"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "Cache 的工作原理是基于 ()。",
        options: [
            "A. 时间局部性原理",
            "B. 空间局部性原理",
            "C. 时间局部性和空间局部性原理",
            "D. 指令局部性原理"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 Cache 映射方式的叙述中，灵活性最高的是 ()。",
        options: [
            "A. 直接映射",
            "B. 全相联映射",
            "C. 组相联映射",
            "D. 段相联映射"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "直接映射方式下，Cache 行号 = ()。",
        options: [
            "A. 主存块号 mod Cache 总行数",
            "B. 主存块号 / Cache 总行数",
            "C. 主存地址 mod Cache 总行数",
            "D. 主存地址 / Cache 总行数"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某 Cache 容量为 16KB，块大小为 64B，采用直接映射方式，主存地址为 32 位，则主存块标记的位数为 ()。",
        options: [
            "A. 16 位",
            "B. 18 位",
            "C. 20 位",
            "D. 22 位"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "虚拟存储器的主要作用是 ()。",
        options: [
            "A. 提高主存的存取速度",
            "B. 扩大主存的寻址空间",
            "C. 提高 Cache 的命中率",
            "D. 扩大 Cache 的容量"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于页式虚拟存储器的叙述中，正确的是 ()。",
        options: [
            "A. 页面大小是固定的",
            "B. 页表存储在 Cache 中",
            "C. 地址转换由软件完成",
            "D. 不会产生页内碎片"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "段式虚拟存储器的优点是 ()。",
        options: [
            "A. 地址转换速度快",
            "B. 不会产生段内碎片",
            "C. 便于程序的模块化设计",
            "D. 存储利用率高"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "TLB（快表）的主要作用是 ()。",
        options: [
            "A. 加速虚拟地址到物理地址的转换",
            "B. 加速主存到 Cache 的数据传输",
            "C. 存储页表的全部内容",
            "D. 扩大虚拟存储器的容量"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 I/O 指令的叙述中，错误的是 ()。",
        options: [
            "A. I/O 指令需要指定设备地址",
            "B. 存储器映像 I/O 方式不需要专门的 I/O 指令",
            "C. I/O 指令的操作码表示对 I/O 设备的操作类型",
            "D. I/O 指令的执行速度比存储器指令快"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "程序控制类指令的功能是 ()。",
        options: [
            "A. 进行算术运算和逻辑运算",
            "B. 进行主存与 CPU 之间的数据传送",
            "C. 改变程序的执行顺序",
            "D. 进行 CPU 与 I/O 设备之间的数据传送"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "条件转移指令的转移条件通常由 () 的状态决定。",
        options: [
            "A. 程序计数器",
            "B. 指令寄存器",
            "C. 状态寄存器（PSW）",
            "D. 地址寄存器"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于子程序调用指令的叙述中，正确的是 ()。",
        options: [
            "A. 调用指令需要保存返回地址",
            "B. 调用指令不需要修改程序计数器",
            "C. 返回指令不需要恢复程序计数器",
            "D. 子程序调用不会产生堆栈操作"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某机器的指令格式中，操作码占 8 位，则该机器最多可设计 () 条指令。",
        options: [
            "A. 8",
            "B. 16",
            "C. 128",
            "D. 256"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "扩展操作码技术的主要目的是 ()。",
        options: [
            "A. 增加指令的寻址空间",
            "B. 缩短指令字长",
            "C. 增加指令的数量",
            "D. 提高指令的执行速度"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下寻址方式中，操作数在寄存器中的是 ()。",
        options: [
            "A. 直接寻址",
            "B. 寄存器寻址",
            "C. 寄存器间接寻址",
            "D. 立即寻址"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "立即寻址方式的优点是 ()。",
        options: [
            "A. 操作数地址灵活",
            "B. 不需要访问主存",
            "C. 寻址空间大",
            "D. 便于修改操作数"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "变址寻址方式中，变址寄存器的内容是 ()。",
        options: [
            "A. 固定的",
            "B. 由用户程序设置的",
            "C. 由操作系统设置的",
            "D. 由硬件自动设置的"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 CISC 和 RISC 的对比，错误的是 ()。",
        options: [
            "A. CISC 指令系统复杂，RISC 指令系统简单",
            "B. CISC 指令长度不固定，RISC 指令长度固定",
            "C. CISC 采用微程序控制器，RISC 采用硬布线控制器",
            "D. CISC 指令执行周期短，RISC 指令执行周期长"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "微程序控制器中，微指令的执行顺序由 () 决定。",
        options: [
            "A. 程序计数器",
            "B. 微程序计数器",
            "C. 指令寄存器",
            "D. 状态寄存器"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "硬布线控制器的优点是 ()。",
        options: [
            "A. 设计灵活",
            "B. 易于修改",
            "C. 执行速度快",
            "D. 成本低"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "指令流水线的“瓶颈”是指 ()。",
        options: [
            "A. 执行时间最长的流水线阶段",
            "B. 执行时间最短的流水线阶段",
            "C. 指令数最多的程序段",
            "D. 指令数最少的程序段"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "流水线的加速比是指 ()。",
        options: [
            "A. 流水线执行时间 / 串行执行时间",
            "B. 串行执行时间 / 流水线执行时间",
            "C. 流水线级数 / 串行执行时间",
            "D. 串行执行时间 / 流水线级数"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 Cache 命中率的叙述中，正确的是 ()。",
        options: [
            "A. Cache 容量越大，命中率越高",
            "B. 块大小越大，命中率越高",
            "C. 程序的局部性越好，命中率越低",
            "D. 映射方式不影响命中率"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "Cache 的写回策略（Write Back）的优点是 ()。",
        options: [
            "A. 一致性好",
            "B. 写操作速度快",
            "C. 硬件实现简单",
            "D. 不需要修改主存"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "Cache 的写直达策略（Write Through）的优点是 ()。",
        options: [
            "A. 写操作速度快",
            "B. 一致性好",
            "C. 减少主存写操作次数",
            "D. 硬件实现复杂"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "虚拟存储器中，页面失效（缺页）的原因是 ()。",
        options: [
            "A. 页面不在主存中",
            "B. 页面不在 Cache 中",
            "C. 页面不在寄存器中",
            "D. 页面不在磁盘中"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "解决缺页的方法是 ()。",
        options: [
            "A. 从 Cache 中调入页面",
            "B. 从磁盘中调入页面",
            "C. 从寄存器中调入页面",
            "D. 直接终止程序执行"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于存储器带宽的叙述中，正确的是 ()。",
        options: [
            "A. 带宽是指存储器的存储容量",
            "B. 带宽是指存储器的存取速度",
            "C. 带宽是指单位时间内存储器传输的数据量",
            "D. 带宽与存储器的层次结构无关"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "CPU 访问存储器的时间是指 ()。",
        options: [
            "A. 从发出地址到数据进入 CPU 的时间",
            "B. 从发出地址到地址稳定的时间",
            "C. 从数据进入 CPU 到数据处理完成的时间",
            "D. 从数据处理完成到数据写回的时间"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于指令执行周期的叙述中，正确的是 ()。",
        options: [
            "A. 所有指令的执行周期都相同",
            "B. 指令的执行周期包括取指、译码、执行、写回等阶段",
            "C. 执行周期只包括运算操作阶段",
            "D. 取指阶段不属于执行周期"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "超标量流水线的主要特点是 ()。",
        options: [
            "A. 一个时钟周期内发射多条指令",
            "B. 流水线级数超过 8 级",
            "C. 指令长度超过 32 位",
            "D. 采用多组寄存器堆"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "超长指令字（VLIW）技术的核心是 ()。",
        options: [
            "A. 硬件自动调度指令",
            "B. 编译器静态调度指令",
            "C. 增加指令的操作码长度",
            "D. 提高 Cache 命中率"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于数据通路的叙述中，正确的是 ()。",
        options: [
            "A. 数据通路是 CPU 中数据传输的路径",
            "B. 数据通路不包括寄存器",
            "C. 数据通路的宽度固定为 32 位",
            "D. 数据通路只能单向传输数据"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "CPU 的时钟周期是指 ()。",
        options: [
            "A. 执行一条指令的时间",
            "B. 完成一个基本操作的时间",
            "C. 完成一次存储器访问的时间",
            "D. 完成一次 I/O 操作的时间"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某 CPU 的时钟频率为 2GHz，则其时钟周期为 ()。",
        options: [
            "A. 0.5ns",
            "B. 1ns",
            "C. 2ns",
            "D. 5ns"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于指令并行性的叙述中，错误的是 ()。",
        options: [
            "A. 指令级并行性可以通过流水线实现",
            "B. 数据相关会降低指令并行性",
            "C. 控制相关会提高指令并行性",
            "D. 编译器优化可以提高指令并行性"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "寄存器堆的主要作用是 ()。",
        options: [
            "A. 存储程序计数器的值",
            "B. 存储指令寄存器的值",
            "C. 提供多个通用寄存器，提高数据访问速度",
            "D. 存储页表项"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于机器语言和汇编语言的叙述中，正确的是 ()。",
        options: [
            "A. 机器语言和汇编语言都是面向机器的语言",
            "B. 汇编语言可以在不同架构的 CPU 上执行",
            "C. 机器语言是高级语言的一种",
            "D. 汇编语言不需要翻译即可执行"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "交叉编译程序的作用是 ()。",
        options: [
            "A. 在目标机上编译源程序",
            "B. 在宿主机上编译生成目标机可执行程序",
            "C. 将机器语言转换为汇编语言",
            "D. 将汇编语言转换为高级语言"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于静态流水线的叙述中，正确的是 ()。",
        options: [
            "A. 同一时间只能执行一种功能",
            "B. 同一时间可以执行多种功能",
            "C. 流水线级数可以动态调整",
            "D. 指令执行顺序可以动态调整"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "动态流水线的主要优点是 ()。",
        options: [
            "A. 硬件实现简单",
            "B. 资源利用率高",
            "C. 执行速度慢",
            "D. 控制逻辑简单"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "Cache 与主存之间的地址映射是由 () 完成的。",
        options: [
            "A. 软件",
            "B. 硬件",
            "C. 编译器",
            "D. 操作系统"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "虚拟存储器的地址转换是由 () 完成的。",
        options: [
            "A. 仅硬件",
            "B. 仅软件",
            "C. 硬件和软件配合",
            "D. 编译器"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于存储保护的叙述中，错误的是 ()。",
        options: [
            "A. 存储保护可以防止程序越界访问",
            "B. 存储保护可以防止多个程序之间的相互干扰",
            "C. 页式存储管理不需要存储保护",
            "D. 段式存储管理便于实现存储保护"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某程序执行过程中，Cache 命中 950 次，主存命中 50 次，则 Cache 的命中率为 ()。",
        options: [
            "A. 5%",
            "B. 90%",
            "C. 95%",
            "D. 99%"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "Cache 的平均访问时间 = ()。",
        options: [
            "A. 命中率 × Cache 访问时间 + 失效率 × 主存访问时间",
            "B. 命中率 × 主存访问时间 + 失效率 × Cache 访问时间",
            "C. Cache 访问时间 + 主存访问时间",
            "D. (Cache 访问时间 + 主存访问时间) / 2"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 DMA 方式的叙述中，正确的是 ()。",
        options: [
            "A. DMA 方式需要 CPU 全程参与数据传输",
            "B. DMA 方式可以提高 I/O 设备与主存之间的数据传输速度",
            "C. DMA 控制器不能独立访问主存",
            "D. DMA 方式会增加 CPU 的负担"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "指令的寻址方式有顺序寻址和跳跃寻址，其中跳跃寻址可以实现 ()。",
        options: [
            "A. 程序的顺序执行",
            "B. 程序的分支和循环",
            "C. 提高指令执行速度",
            "D. 扩大寻址空间"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于堆栈的叙述中，错误的是 ()。",
        options: [
            "A. 堆栈是一种“后进先出”的存储结构",
            "B. 堆栈指针指向栈底元素",
            "C. 压栈操作会使堆栈指针减 1（向下生长）",
            "D. 出栈操作会使堆栈指针加 1（向下生长）"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "RISC 处理器通常采用 () 控制器。",
        options: [
            "A. 微程序",
            "B. 硬布线",
            "C. 组合逻辑",
            "D. 可编程逻辑"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "CISC 处理器通常采用 () 控制器。",
        options: [
            "A. 微程序",
            "B. 硬布线",
            "C. 组合逻辑",
            "D. 可编程逻辑"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "流水线的冒险（Hazard）不包括 ()。",
        options: [
            "A. 结构冒险",
            "B. 数据冒险",
            "C. 控制冒险",
            "D. 地址冒险"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "结构冒险的主要原因是 ()。",
        options: [
            "A. 多条指令争用同一硬件资源",
            "B. 后一条指令需要前一条指令的结果",
            "C. 指令跳转导致流水线清空",
            "D. 操作数地址计算错误"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "控制冒险的主要原因是 ()。",
        options: [
            "A. 多条指令争用同一硬件资源",
            "B. 后一条指令需要前一条指令的结果",
            "C. 指令跳转导致流水线清空",
            "D. 操作数地址计算错误"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于预取指令的叙述中，正确的是 ()。",
        options: [
            "A. 预取指令可以提高流水线的效率",
            "B. 预取指令会增加结构冒险",
            "C. 预取指令不需要考虑指令的局部性",
            "D. 预取指令只能在 Cache 中进行"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "存储层次的设计目标是 ()。",
        options: [
            "A. 速度最快",
            "B. 容量最大",
            "C. 成本最低",
            "D. 速度接近 Cache、容量接近辅存、成本接近主存"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于页表的叙述中，正确的是 ()。",
        options: [
            "A. 页表存储在寄存器中",
            "B. 页表的每一项对应一个页面，包含页面的物理地址等信息",
            "C. 页表的大小与页面大小无关",
            "D. 页表不需要更新"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "多级页表的主要目的是 ()。",
        options: [
            "A. 提高地址转换速度",
            "B. 减少页表占用的主存空间",
            "C. 增加虚拟地址空间",
            "D. 提高页面命中率"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "指令的操作数可以是立即数、寄存器操作数和存储器操作数，其中访问速度最快的是 ()。",
        options: [
            "A. 立即数",
            "B. 寄存器操作数",
            "C. 存储器操作数",
            "D. 三者速度相同"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于机器级程序的叙述中，错误的是 ()。",
        options: [
            "A. 机器级程序由二进制指令组成",
            "B. 机器级程序的执行效率与指令的顺序无关",
            "C. 机器级程序的可读性差",
            "D. 机器级程序与 CPU 架构相关"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "编译器对高级语言程序的优化不包括 ()。",
        options: [
            "A. 指令重排",
            "B. 常量折叠",
            "C. 循环展开",
            "D. 增加指令条数"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于指令集架构（ISA）的叙述中，正确的是 ()。",
        options: [
            "A. ISA 是软件和硬件之间的接口",
            "B. ISA 只定义指令的操作码格式",
            "C. 不同架构的 CPU 具有相同的 ISA",
            "D. ISA 不影响编译器的设计"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某指令的格式为：OP（6 位）+ 源寄存器（5 位）+ 目的寄存器（5 位）+ 立即数（16 位），则该指令字长为 ()。",
        options: [
            "A. 16 位",
            "B. 32 位",
            "C. 64 位",
            "D. 128 位"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于寻址空间的叙述中，正确的是 ()。",
        options: [
            "A. 寻址空间由地址码的位数决定",
            "B. 寻址空间由操作码的位数决定",
            "C. 寻址空间与寄存器数量有关",
            "D. 寻址空间与 Cache 容量有关"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "自陷指令（Trap）的主要作用是 ()。",
        options: [
            "A. 实现程序的分支跳转",
            "B. 触发系统调用，进入内核态",
            "C. 进行算术运算和逻辑运算",
            "D. 实现数据的输入输出"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于特权指令的叙述中，正确的是 ()。",
        options: [
            "A. 特权指令可以在用户态执行",
            "B. 特权指令主要用于访问系统资源",
            "C. 所有指令都是特权指令",
            "D. 特权指令不需要操作系统授权"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "CPU 的用户态和内核态切换的主要触发条件是 ()。",
        options: [
            "A. 指令执行完毕",
            "B. 发生中断或异常",
            "C. Cache 失效",
            "D. 页面失效"
        ],
        answer: "B"
    },
    // 第四章 程序的链接（35题）
    {
        chapter: "第四章 程序的链接",
        question: "以下有关使用 GCC 生成 C 语言程序的可执行文件的叙述中，错误的是 ()。",
        options: [
            "A. 第一步预处理，对 #include、#define、#ifdef 等预处理命令进行处理",
            "B. 第二步编译，将预处理结果编译转换为二进制形式的汇编语言程序代码",
            "C. 第三步汇编，将汇编语言代码汇编转换为机器指令表示的机器语言代码",
            "D. 第四步链接，将多个模块的机器语言代码链接生成可执行目标程序文件"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关使用 GCC 生成 C 语言程序的可执行文件的叙述中，错误的是 ()。",
        options: [
            "A. 预处理的结果还是一个 C 语言源程序文件，属于可读的文本文件",
            "B. 经过预处理、编译和汇编处理的结果是一个可重定位目标文件",
            "C. 每个 C 语言源程序文件生成一个对应的可重定位目标文件",
            "D. 只要在链接命令中指定所有的相关可重定位目标文件，就能生成可执行文件"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关链接所带来的好处和不足的叙述中，错误的是 ()。",
        options: [
            "A. 使得程序员可以分模块开发程序，有利于提高大规模程序的开发效率",
            "B. 使得公共函数库可以为所有程序共享使用，有利于代码重用和提高效率",
            "C. 使得程序员仅需重新编译修改过的源程序模块，从而节省程序开发时间",
            "D. 使得所生成的可执行目标代码中包含了更多公共库函数代码，所占空间大"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 目标文件格式的叙述中，错误的是 ()。",
        options: [
            "A. 可重定位目标文件是 ELF 格式的链接视图，由不同的节组成",
            "B. 可执行目标文件是 ELF 格式的执行视图，由不同的段组成",
            "C. 可重定位和可执行两种目标文件中的数据都是二进制表示的补码形式",
            "D. 可重定位和可执行两种目标文件中的代码都是二进制表示的指令形式"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于链接器基本功能的叙述中，错误的是 ()。",
        options: [
            "A. 将每个符号引用与唯一的一个符号定义进行关联",
            "B. 将每个.o 文件中的.data 节、.text 节和.bss 节分别合并",
            "C. 确定每个符号 (包括全局变量和局部变量) 的首地址",
            "D. 根据所定义符号的首地址对符号的引用进行重定位"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于可重定位目标文件的叙述中，错误的是 ()。",
        options: [
            "A. 在.text 节中包含相应模块内所有机器代码",
            "B. 在.data 节中包含相应模块内所有变量的初始值",
            "C. 在.rodata 节中包含相应模块内所有只读数据",
            "D. 在.rel.text 节和.rel.data 节中包含相应节内所有可重定位信息"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 目标文件的 ELF 头的叙述中，错误的是 ()。",
        options: [
            "A. 包含了 ELF 头本身的长度和目标文件的长度",
            "B. 包含了操作系统版本和机器结构类型等信息",
            "C. 包含了节头表和程序头表各自的起始位置和长度",
            "D. 数据结构在可重定位和可执行两种目标文件中完全一样"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 目标文件的节头表的叙述中，错误的是 ()。",
        options: [
            "A. 每个表项用来记录某个节的内容以及相关描述信息",
            "B. 通过节头表可获得节的名称、类型、起始地址和长度",
            "C. 描述了每个可装入节的起始虚拟地址、对齐和存取方式",
            "D. 数据结构在可重定位和可执行两种目标文件中完全一样"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 可重定位和可执行两种目标文件格式比较的叙述中，错误的是 ()。",
        options: [
            "A. 可重定位目标文件中有可重定位节.rel.text 和.rel.data，在可执行目标文件中则没有",
            "B. 可重定位目标文件中有初始化程序段.init 节，在可执行目标文件中则没有",
            "C. 可执行目标文件中有程序头表 (段头表)，在可重定位目标文件中则没有",
            "D. 可执行目标文件的 ELF 头中有具体程序入口地址，在可重定位目标文件中则为 0"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 可执行目标文件的程序头表 (段头表) 的叙述中，错误的是 ()。",
        options: [
            "A. 用于描述可执行文件中的节与主存储器中的存储段之间的映射关系",
            "B. 通过段头表可获得可装入段或特殊段的类型、在文件中的偏移位置及长度",
            "C. 描述了每个可装入段的起始虚拟地址、存储长度、存取方式和对齐方式",
            "D. .text 节和.rodata 节都包含在只读代码段，而.data 节和.bss 节都包含在读写数据段"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于链接过程中对符号定义的判断中，错误的是 ()。",
        options: [
            "A. 全局变量声明 \"int x, y ;\" 中，x 和 y 都是符号的定义",
            "B. 全局变量声明 \"int*xp=&x;\" 中，xp 和 x 都是符号的定义",
            "C. 静态局部变量声明 \"static int x=*xp ;\" 中，x 是符号的定义",
            "D. 函数内的局部变量声明 \"short x=200 ;\" 中，x 不是符号的定义"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "若 x 为局部变量，xp、y 和 z 是全局变量，则以下判断中错误的是 ()。",
        options: [
            "A. 赋值语句 \"int y=x+z ;\" 中，y 和 z 都是符号的引用",
            "B. 赋值语句 \"y=x+z ;\" 中，y 和 z 都是符号的引用",
            "C. 静态局部变量声明 \"static int x=*xp ;\" 中，xp 是符号的引用",
            "D. 赋值语句 \"y=x+*xp ;\" 中，y 和 xp 都是符号的引用"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关链接符号类型的叙述中，错误的是 ()。",
        options: [
            "A. 由模块 m 定义并能被其他模块引用的符号称为 m 的全局符号",
            "B. 由其他模块定义并被模块 m 引用的符号称为 m 的外部符号",
            "C. 由模块 m 定义并仅在 m 中引用的符号称为 m 的本地符号",
            "D. 在模块 m 内的某个函数中定义的局部变量称为 m 的局部符号"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关 ELF 目标文件的符号表的叙述中，错误的是 ()。",
        options: [
            "A. 可重定位和可执行两种目标文件中都有符号表且数据结构一样",
            "B. 符号表定义在.symtab 节中，每个表项描述某个符号的相应信息",
            "C. 通过符号表可获得符号的名称、所在节及在节中偏移地址和长度",
            "D. 符号表中包含了所有定义符号的描述信息，包括局部变量的相关信息"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是有关链接过程中符号解析 (符号绑定) 的叙述，错误的是 ()。",
        options: [
            "A. 符号解析的目的是将符号引用与某目标模块中定义的符号建立关联",
            "B. 同一个符号名可能在多个模块中有定义，每个定义处的符号都须分配空间",
            "C. 本地符号的解析比较简单，只要与本模块内定义的符号关联即可",
            "D. 全局符号 (包括外部符号) 需将模块内的引用与模块外的定义符号绑定"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关强符号和弱符号定义的叙述中，错误的是 ()。",
        options: [
            "A. 局部符号没有强、弱符号的概念",
            "B. 所有出现的函数名都是强符号",
            "C. 没有初始化的全局变量名是弱符号",
            "D. 已初始化的全局变量名是强符号"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关强符号和弱符号的符号解析的叙述中，错误的是 ()。",
        options: [
            "A. 一个符号名只能有一个强符号，否则符号解析失败",
            "B. 一个符号名可以有多个弱符号，任选一个为其定义",
            "C. 一个符号名可以有一个强符号和多个弱符号，强符号为其定义",
            "D. 一个符号名可以仅出现在引用处或仅出现在定义处"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/m1.c/ int p(void); int main() { int p1=p(); return p1; } /m2.c/ static int main=1; int p () { main++; return main; } 对于上述两个源程序文件链接时的符号解析，错误的是 ()。",
        options: [
            "A. 在 m1 中，定义了一个强符号 main 和一个弱符号 p",
            "B. 在 m2 中，定义了一个强符号 p 和一个本地符号 main",
            "C. 在 m1 中，对 m2 中定义的强符号 p 的引用只有一处",
            "D. 因为出现了两个强符号 main，所以会发生链接错误"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/m1.c/ int p(void); int main() { int p1=p(); return p1; } /m2.c/ int main=1; int p () { int p1=main++; return main; } 对于上述两个源程序文件链接时的符号解析，错误的是 ()。",
        options: [
            "A. 在 m1 中，定义了一个强符号 main 和一个弱符号 p",
            "B. 在 m2 中，定义了一个强符号 p 和一个强符号 main",
            "C. 在模块 m1 的所有语句中，对符号 p1 的引用共有两处",
            "D. 因为出现了两个强符号 main，所以会发生链接错误"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/m1.c/ int x=100; int p1(void); int main() { x=p1(); return x; } /m2.c/ float x; static main=1; int p1 () { int p1=main+(int) x; return p1; } 对于上述两个源程序文件链接时的符号解析，错误的是 ()。",
        options: [
            "A. m1 中对 x 的两处引用都与 m1 中对 x 的定义绑定",
            "B. m2 中对 x 的引用与 m2 中对 x 的定义绑定",
            "C. m2 中的变量 p1 与函数 p1 被分配在不同存储区",
            "D. 虽然 x、main 和 p1 都出现了多次定义，但不会发生链接错误"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/m1.c/ int x=100; short y=1,z=2; int main() { p1(); printf(\"x=%d,z=%d\\n\",x,z); } /m2.c/ double x; void p1 () { x=-1.0; } 上述程序执行的结果是 ()。(提示：1074790400=2³⁰+2²⁰，16400=2¹⁴+2⁴)",
        options: [
            "A. x=100, z=2",
            "B. x=-1, z=2",
            "C. x=-1074790400, z=0",
            "D. x=0, z=-16400"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假设调用关系如下：func.o→libx.a 和 liby.a 中的函数，libx.a→libz.a 中的函数，libx.a 和 liby.a 之间、liby.a 和 libz.a 相互独立，则以下几个命令行中，静态链接发生错误的命令是 ()。",
        options: [
            "A. gcc -static -o myfunc func.o libx.a liby.a libz.a",
            "B. gcc -static -o myfunc func.o liby.a libz.a libx.a",
            "C. gcc -static -o myfunc func.o libx.a libz.a liby.a",
            "D. gcc -static -o myfunc func.o liby.a libx.a libz.a"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假设调用关系如下：func1.o→func2.o，func1.o→libx.a 中的函数，func2.o→libx.a 中的函数，libx.a→liby.a 同时 liby.a→libx.a，则以下命令行中，能够正确进行静态链接的命令是 ()。",
        options: [
            "A. gcc -static -o myfunc func1.o func2.o libx.a liby.a libx.a",
            "B. gcc -static -o myfunc func2.o func1.o liby.a libx.a liby.a",
            "C. gcc -static -o myfunc libx.a liby.a libx.a func1.o func2.o",
            "D. gcc -static -o myfunc liby.a libx.a liby.a func1.o func2.o"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关重定位功能的叙述中，错误的是 ()。",
        options: [
            "A. 重定位的最终目标是重新确定各模块合并后每个引用所指向的目标地址",
            "B. 重定位的第一步应先将相同的节合并，且将具有相同存取属性的节合并成段",
            "C. 重定位的第二步是确定每个段的起始地址，并确定段内每个定义处符号的地址",
            "D. 重定位的最后一步是将引用处的地址修改为与之关联 (绑定) 的定义处的首地址"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关重定位信息的叙述中，错误的是 ()。",
        options: [
            "A. 重定位信息是由编译器在生成汇编指令时产生的",
            "B. 指令中的重定位信息在可重定位目标文件的.rel.text 节中",
            "C. 数据中的重定位信息在可重定位目标文件的.rel.data 节中",
            "D. 重定位信息包含需要重定位的位置、绑定的符号和重定位类型"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关 IA-32 的重定位类型的叙述中，错误的是 ()。",
        options: [
            "A. 基本重定位类型有绝对地址和 PC 相对地址两种方式",
            "B. 对于过程调用中的引用，通常在 CALL 指令中采用 PC 相对地址方式",
            "C. PC 相对地址指引用所绑定符号的地址与当前 PC 的相对地址是重定位值",
            "D. 过程调用相关的重定位中，PC 相对地址中使用的当前 PC 是指 CALL 指令的地址"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假定 \"int buf [2]={10,50};\" 所定义的 buf 被分配在静态数据区，其首地址为 0x8048930，bufp1 为全局变量，被分配在 buf 随后的存储空间。以下关于 \"int*bufp1=&buf [1];\" 的重定位的描述中，错误的是 ()。",
        options: [
            "A. bufp1 的地址为 0x8048938，重定位前的内容为 04H、00H、00H、00H",
            "B. 在可重定位目标文件的.rel.data 节中，有一个引用 buf 的重定位条目",
            "C. 在相应的重定位条目中，对 bufp1 和 buf 的引用均采用绝对地址方式",
            "D. 在可执行目标文件中，地址 0x8048938 开始的 4 个字节为 34H、89H、04H、08H"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假定 \"int buf [2]={10,50};\" 所定义的 buf 被分配在静态数据区，其首地址为 0x8048930，bufp1 为全局变量，也被分配在静态数据区。以下关于 \"bufp1=&buf [1];\" 的重定位的描述中，错误的是 ()。",
        options: [
            "A. 在可重定位目标文件的.rel.data 节中，有一个与 bufp1 相关的重定位条目",
            "B. 在可重定位目标文件的.rel.text 节中，有一个与 buf 相关的重定位条目",
            "C. 在相应的重定位条目中，对 bufp1 和 buf 的引用均采用绝对地址方式",
            "D. 可用一条 mov 指令实现该赋值语句，该 mov 指令中有两处需要重定位"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关在 Linux 系统中启动可执行目标文件执行的叙述中，错误的是 ()。",
        options: [
            "A. 可在 GUI (命令行用户界面) 中双击可执行目标文件对应的图标来启动其执行",
            "B. 可在 GUI (命令行用户界面) 中的命令行提示符后输入对应的命令来启动其执行",
            "C. 可以通过在一个程序中调用 execve () 系统调用函数来启动可执行文件执行",
            "D. 不管是哪种启动执行方式，最终都是通过调用 execve () 系统调用函数实现的"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关在 Linux 系统中加载可执行目标文件的叙述中，错误的是 ()。",
        options: [
            "A. 可执行目标文件的加载通过 execve () 函数调用的加载器来完成",
            "B. 加载器通过可执行目标文件中的程序头表对可装入段进行加载",
            "C. 在可执行目标文件的加载过程中，其中的指令和数据被读入主存储器",
            "D. 任何可执行目标文件中的可装入段被映射到一个统一的虚拟地址空间"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是在 Linux 系统中启动并加载可执行目标文件过程中 shell 命令行解释程序所做的部分操作：①构造 argv 和 envp ②调用 fork () 系统调用函数 ③调用 execve () 系统调用函数 ④读入命令 (可执行文件名) 及参数 启动并加载可执行目标文件的正确步骤是 ()。",
        options: [
            "A. ①→②→③→④",
            "B. ②→④→①→③",
            "C. ④→①→②→③",
            "D. ④→①→③→②"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关动态链接及其所链接的共享库以及动态链接生成的可执行目标文件的叙述中，错误的是 ()。",
        options: [
            "A. 共享库在 Linux 下称为动态共享对象 (.so)，在 Windows 下称为动态链接库 (.dll)",
            "B. 生成的可执行目标文件是部分链接的，也即其中还有部分引用没有进行重定位",
            "C. 可执行目标文件由动态链接器对可重定位目标文件和共享库中部分信息进行链接而成",
            "D. 可执行目标文件在加载或执行时，系统将会调出动态链接器利用共享库对其进行动态链接"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关静态链接和动态链接比较的叙述中，错误的是 ()。",
        options: [
            "A. 静态库函数代码包含在进程代码段中，而共享库函数代码不包含在进程代码段中",
            "B. 静态库函数代码包含在可执行目标文件中，而共享库函数代码不包含在可执行目标文件中",
            "C. 静态库函数更新后需对程序重新编译和链接，而共享库函数更新后程序无需重新编译和链接",
            "D. 静态库函数在加载时被链接，而共享库函数可在加载或运行时被链接"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关动态链接所用共享库代码的叙述中，错误的是 ()。",
        options: [
            "A. 共享库代码一定是位置无关代码 (PIC)",
            "B. 用 GCC 生成共享库文件时应使用 - PIC 选项",
            "C. 链接器可将共享库代码映射到不同的地址运行",
            "D. 共享库代码长度发生变化时会影响调用它的程序"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "一个共享库文件 (.so 文件) 由多个模块 (.o 文件) 生成。在生成共享库文件的过程中，需要对.o 文件进行处理，以生成位置无关代码。以下有关位置无关代码 (PIC) 生成的叙述中，错误的是 ()。",
        options: [
            "A. 模块内函数之间的调用可用 PC 相对地址实现，无需动态链接器进行重定位",
            "B. 模块内数据的引用无需动态链接器进行重定位，因为引用与定义间相对位置固定",
            "C. 模块外数据的引用需要动态链接器进行重定位，重定位时在 GOT 中填入外部数据的地址",
            "D. 模块间函数调用需要动态链接器进行重定位，重定位时在 GOT 和 PLT 中填入相应内容"
        ],
        answer: "D"
    },
    // 第五章 程序的执行（18题）
    {
        chapter: "第五章 程序的执行",
        question: "计算机中的核心时序信号是 ()。",
        options: [
            "A. CPU 时钟周期",
            "B. 主板时钟周期",
            "C. 指令周期",
            "D. 存储周期"
        ],
        answer: "A"
    },
    {
        chapter: "第五章 程序的执行",
        question: "CPU 中控制器的功能是 ()。",
        options: [
            "A. 产生时序信号",
            "B. 控制从主存取出一条指令",
            "C. 完成指令操作码译码",
            "D. 完成指令操作码译码，并产生操作控制信号"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "冯・诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 依据 () 来区分它们。",
        options: [
            "A. 指令和数据的表示形式不同",
            "B. 指令和数据的寻址方式不同",
            "C. 指令和数据的访问时点不同",
            "D. 指令和数据的地址形式不同"
        ],
        answer: "C"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列寄存器中，对汇编语言程序员不透明的是 ()。",
        options: [
            "A. 存储器地址寄存器 MAR",
            "B. 程序计数器 PC",
            "C. 存储器数据寄存器 MDR",
            "D. 指令寄存器 IR"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关 CPU 中部分部件的功能的描述中，错误的是 ()。",
        options: [
            "A. 控制单元用于对指令操作码译码并生成控制信号",
            "B. PC 称为程序计数器，用于存放将要执行的指令的地址",
            "C. 通过将 PC 按当前指令长度增量，可实现指令的按序执行",
            "D. IR 称为指令寄存器，用来存放当前指令的操作码"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "执行完当前指令后，PC 中存放的是后继指令的地址，因此 PC 的位数和 () 的位数相同。",
        options: [
            "A. 指令寄存器 IR",
            "B. 指令译码器 ID",
            "C. 存储器地址寄存器 MAR",
            "D. 程序状态字寄存器 PSWR"
        ],
        answer: "C"
    },
    {
        chapter: "第五章 程序的执行",
        question: "通常情况下，下列 () 部件不包含在中央处理器 (CPU) 芯片中。",
        options: [
            "A. ALU",
            "B. 控制器",
            "C. 通用寄存器",
            "D. DRAM"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关程序计数器 PC 的叙述中，错误的是 ()。",
        options: [
            "A. 每条指令执行后，PC 的值都会被改变",
            "B. 指令顺序执行时，PC 的值总是自动加 1",
            "C. 调用指令执行后，PC 的值一定是被调用过程的入口地址",
            "D. 无条件转移指令执行后，PC 的值一定是转移目标地址"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "CPU 取出一条指令并执行所用的时间被称为 ()。",
        options: [
            "A. 时钟周期",
            "B. CPU 周期",
            "C. 机器周期",
            "D. 指令周期"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关指令周期的叙述中，错误的是 ()。",
        options: [
            "A. 指令周期的第一个阶段一定是取指令阶段",
            "B. （原题选项 B 缺失）",
            "C. 一个指令周期由若干个机器周期或时钟周期组成",
            "D. 相对于 RISC，CISC 风格处理器的指令周期更长"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关 CPU 时钟信号的叙述中，错误的是 ()。",
        options: [
            "A. 处理器总是每来一个时钟信号就开始执行一条新的指令",
            "B. 边沿触发指状态单元总在时钟上升沿或下降沿开始改变状态",
            "C. 时钟周期以相邻状态单元之间最长组合逻辑延迟为基准确定",
            "D. 每个时钟周期称为一个节拍，机器的主频就是时钟周期的倒数"
        ],
        answer: "A"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关数据通路的叙述中，错误的是 ()。",
        options: [
            "A. 数据通路由若干操作元件和状态元件连接而成",
            "B. 数据通路的功能由控制部件送出的控制信号决定",
            "C. ALU 属于操作元件，用于执行各类算术和逻辑运算",
            "D. 通用寄存器属于状态元件，但不包含在数据通路中"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "以下关于指令流水线设计的叙述中，错误的是 ()。",
        options: [
            "A. 指令执行过程中的各个子功能都须包含在某个流水段中",
            "B. 所有子功能都必须按一定的顺序经过流水段",
            "C. 虽然各子功能所用实际时间可能不同，但经过每个流水段的时间都一样",
            "D. 任何时候各个流水段的功能部件都不可能执行空 (nop) 操作"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关 RISC 特征的描述中，错误的是 ()。",
        options: [
            "A. 指令格式规整，寻址方式少",
            "B. 采用硬连线控制和指令流水线",
            "C. 配置的通用寄存器数目不多",
            "D. 运算类指令的操作数不访存"
        ],
        answer: "C"
    },
    {
        chapter: "第五章 程序的执行",
        question: "以下关于指令流水线和指令执行效率关系的叙述中，错误的是 ()。",
        options: [
            "A. 加倍增加流水段个数不能成倍提高指令执行效率",
            "B. 为了提高指令吞吐率，流水段个数可以无限制地增多",
            "C. 加深流水线深度，可以提高处理器的时钟频率",
            "D. 随着流水段个数的增加，流水段之间缓存开销的比例增大"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "某计算机的指令流水线由 4 个功能段组成，指令流经各功能段的时间 (忽略各功能段之间流水段寄存器的缓存时间) 分别为 90ns、80ns、70ns 和 60ns，则该计算机的 CPU 时钟周期至少是 ()。",
        options: [
            "A. 90ns",
            "B. 80ns",
            "C. 70ns",
            "D. 60ns"
        ],
        answer: "A"
    },
    {
        chapter: "第五章 程序的执行",
        question: "假定执行最复杂的指令需要完成 6 个子功能，分别由对应的功能部件 A~F 来完成，每个功能部件所花的时间分别为 80ps、40ps、50ps、70ps、20ps、30ps，流水段寄存器延时为 20ps，现把最后两个功能部件 E 和 F 合并，以产生一个 5 段流水线。该 5 段流水线的时钟周期至少是 () ps。",
        options: [
            "A. 70",
            "B. 80",
            "C. 90",
            "D. 100"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "以下给定的说法中，不会引起指令流水线阻塞的是 ()。",
        options: [
            "A. 外部中断",
            "B. 指令数据相关",
            "C. 执行空操作指令",
            "D. 条件转移"
        ],
        answer: "C"
    },
    // 第六章 层次结构存储系统（43题）
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面有关半导体存储器组织的叙述中，错误的是 ()。",
        options: [
            "A. 存储器的核心部分是存储阵列，由若干存储单元构成",
            "B. 存储单元由若干个存放 0 或 1 的存储元件构成",
            "C. 一个存储单元有一个编号，就是存储单元的地址",
            "D. 同一个存储器中，每个存储单元的宽度可以不同"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面 4 种存储器中，目前已被淘汰的是 ()。",
        options: [
            "A. 半导体存储器",
            "B. 磁表面存储器",
            "C. 磁芯存储器",
            "D. 光盘存储器"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "若计算机的主存储器容量为 1GB，也就等于 ()。",
        options: [
            "A. 2³⁰个字节",
            "B. 10³⁰个字节",
            "C. 2¹⁰个字节",
            "D. 10⁹个字节"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "某 SRAM 芯片的容量为 1024x4 位，则地址和数据引脚的数目分别为 ()。",
        options: [
            "A. 10，4",
            "B. 5，4",
            "C. 10，8",
            "D. 5，8"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "某计算机字长 16 位，主存地址空间大小是 64KB，按字节编址，则寻址范围是 ()。",
        options: [
            "A. 0 ~(64K-1)",
            "B. 0 ~(32K-1)",
            "C. 0 ~(64KB-1)",
            "D. 0 ~(32KB-1)"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下选项中，属于可擦除可编程只读存储器的是 ()。",
        options: [
            "A. 读写存储器",
            "B. 掩膜只读存储器",
            "C. 可编程的只读存储器",
            "D. 可擦除可编程的只读存储器"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下列几种存储器中，() 是易失性存储器。",
        options: [
            "A. cache",
            "B. EPROM",
            "C. Flash Memory",
            "D. CD-ROM"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址空间大小为 1024MB，按字节编址，每次读写操作最多可以一次存取 32 位。不考虑其他因素，则存储器地址寄存器 MAR 和存储器数据寄存器 MDR 的位数至少应分别为 ()。",
        options: [
            "A. 30，8",
            "B. 30，32",
            "C. 28，8",
            "D. 28，32"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "需要定时刷新的半导体存储器芯片是 ()。",
        options: [
            "A. SRAM",
            "B. DRAM",
            "C. EPROM",
            "D. Flash Memory"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "通常采用行、列地址引脚复用的半导体存储器芯片是 ()。",
        options: [
            "A. SRAM",
            "B. DRAM",
            "C. EPROM",
            "D. Flash Memory"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "具有 RAS (行地址选通) 和 CAS (列地址选通) 信号引脚的半导体存储器芯片是 ()。",
        options: [
            "A. SRAM",
            "B. DRAM",
            "C. EPROM",
            "D. Flash Memory"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面有关 ROM 和 RAM 的叙述中，错误的是 ()。",
        options: [
            "A. RAM 是可读可写存储器，ROM 是只读存储器",
            "B. ROM 和 RAM 都采用随机访问方式进行读写",
            "C. 系统的主存由 RAM 和 ROM 组成",
            "D. 系统的主存都用 DRAM 芯片实现"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面有关半导体存储器的叙述中，错误的是 ()。",
        options: [
            "A. 半导体存储器都采用随机存取方式进行读写",
            "B. ROM 芯片属于半导体随机存储器芯片",
            "C. SRAM 是半导体静态随机访问存储器，可用作 cache",
            "D. DRAM 是半导体动态随机访问存储器，可用作主存"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定 DDR3 SDRAM 芯片内部核心频率为 133.25MHz，与之相连的存储器总线每次传输 8 字节，则下面有关叙述中，错误的是 ()。",
        options: [
            "A. 芯片内部 I/O 缓冲采用 8 位预取技术",
            "B. 存储器总线每秒传 1066M 次数据",
            "C. 存储器总线的时钟频率为 1066MHz",
            "D. 存储器总线的带宽大约为 8.5GB/s"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定用若干个 16Kx1 位的存储器芯片组成一个 64Kx8 位的存储器，芯片内各单元连续编址，则地址为 8000H 所在的芯片的最小地址为 ()。",
        options: [
            "A. 4000H",
            "B. 6000H",
            "C. 8000H",
            "D. A000H"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定用若干个 16Kx8 位的存储器芯片组成一个 64Kx8 位的存储器，芯片各单元交叉编址，则地址 BFFFH 所在的芯片的最小地址为 ()。",
        options: [
            "A. 0000H",
            "B. 0001H",
            "C. 0002H",
            "D. 0003H"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "用存储容量为 16Kx1 位的存储器芯片组成一个 64Kx8 位的存储器，则在字方向和位方向上分别扩展了 () 倍。",
        options: [
            "A. 4 和 2",
            "B. 4 和 8",
            "C. 2 和 4",
            "D. 8 和 4"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "存储容量为 16Kx4 位的 DRAM 芯片，其地址引脚和数据引脚数各是 ()。",
        options: [
            "A. 7 和 1",
            "B. 7 和 4",
            "C. 14 和 1",
            "D. 14 和 4"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "多模块存储器之所以能高速进行读 / 写，是因为 ()。",
        options: [
            "A. 采用了高速元器件",
            "B. 各模块有独立的读写电路",
            "C. 采用了信息预读技术",
            "D. 模块内各单元地址连续"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "相联存储器是按 () 进行寻址访问的存储器。",
        options: [
            "A. 地址指定方式",
            "B. 内容指定方式",
            "C. 堆栈访问方式",
            "D. 队列访问方式"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下是有关磁盘驱动器的叙述，其中错误的是 ()。",
        options: [
            "A. 送到磁盘驱动器的盘地址由磁头号、盘面号和扇区号组成",
            "B. 能控制磁头移动到指定磁道，并发回 \"寻道结束\" 信号",
            "C. 能控制磁盘片转过指定的扇区，并发回 \"扇区符合\" 信号",
            "D. 能对指定盘面的指定扇区进行数据的读或写操作"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定一个磁盘存储器有 4 个盘片，用于记录信息的柱面数为 2000，每个磁道上有 3000 个扇区，每个扇区 512B，则该磁盘存储器的容量约为 ()。",
        options: [
            "A. 12MB",
            "B. 24MB",
            "C. 12GB",
            "D. 24GB"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定一个磁盘的转速为 7200RPM，磁盘的平均寻道时间为 20ms，平均数据传输率为 1MB/s，不考虑排队等待时间，那么读一个 512 字节的扇区的平均时间大约为 ()。",
        options: [
            "A. 14.7ms",
            "B. 18.8ms",
            "C. 24.7ms",
            "D. 28.8ms"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "在存储器分层体系结构中，存储器速度从最快到最慢的排列顺序是 ()。",
        options: [
            "A. 寄存器 - 主存 - cache - 辅存",
            "B. 寄存器 - 主存 - 辅存 - cache",
            "C. 寄存器 - cache - 辅存 - 主存",
            "D. 寄存器 - cache - 主存 - 辅存"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "在存储器分层体系结构中，存储器从容量最大到最小的排列顺序是 ()。",
        options: [
            "A. 主存 - 辅存 - cache - 寄存器",
            "B. 辅存 - cache - 主存 - 寄存器",
            "C. 辅存 - 主存 - cache - 寄存器",
            "D. 辅存 - 主存 – 寄存器 – cache"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "在主存和 CPU 之间增加 cache 的目的是 ()。",
        options: [
            "A. 增加内存容量",
            "B. 提高内存可靠性",
            "C. 加快信息访问速度",
            "D. 增加内存容量，同时加快访问速度"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下哪一种情况能很好地发挥 cache 的作用？()。",
        options: [
            "A. 程序中不含有过多的 I/O 操作",
            "B. 程序的大小不超过实际的内存容量",
            "C. 程序具有较好的访问局部性",
            "D. 程序的指令间相关度不高"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址位数为 32 位，按字节编址，主存和 cache 之间采用直接映射方式，主存块大小为 1 个字，每字 32 位，写操作时采用直写 (write through) 方式，则能存放 32K 字数据的 cache 的总容量至少应有多少位？()。",
        options: [
            "A. 1504K",
            "B. 1536K",
            "C. 1568K",
            "D. 1600K"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址位数为 32 位，按字节编址，主存和 cache 之间采用直接映射方式，主存块大小为 1 个字，每字 32 位，写操作时采用回写 (write back) 方式，则能存放 32K 字数据的 cache 的总容量至少应有多少位？()。",
        options: [
            "A. 1504K",
            "B. 1536K",
            "C. 1568K",
            "D. 1600K"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址位数为 32 位，按字节编址，主存和 cache 之间采用全相联映射方式，主存块大小为 1 个字，每字 32 位，采用回写 (write back) 方式和随机替换策略，则能存放 32K 字数据的 cache 的总容量至少应有多少位？()。",
        options: [
            "A. 1536K",
            "B. 1568K",
            "C. 2016K",
            "D. 2048K"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存按字节编址，cache 共有 64 行，采用直接映射方式，主存块大小为 32 字节，所有编号都从 0 开始。问主存第 2593 号单元所在主存块对应的 cache 行号是 ()。",
        options: [
            "A. 1",
            "B. 17",
            "C. 34",
            "D. 81"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存按字节编址，cache 共有 64 行，采用 4 路组相联映射方式，主存块大小为 32 字节，所有编号都从 0 开始。问主存第 2593 号单元所在主存块对应的 cache 组号是 ()。",
        options: [
            "A. 1",
            "B. 17",
            "C. 34",
            "D. 81"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需 1 个时钟周期，存储器准备一个数据需 8 个时钟周期，总线上每传送 1 个数据需 1 个时钟周期。若主存和 cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 4B，则 cache 的一次缺失损失至少为多少个时钟周期？()。",
        options: [
            "A. 64",
            "B. 72",
            "C. 80",
            "D. 160"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需 1 个时钟周期，存储器准备一个数据需 8 个时钟周期，总线上每传送 1 个数据需 1 个时钟周期。若主存和 cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 cache 的一次缺失损失至少为多少个时钟周期？()。",
        options: [
            "A. 64",
            "B. 72",
            "C. 80",
            "D. 160"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定采用多模块交叉存储器组织方式，存储器芯片和总线支持突发传送，CPU 通过存储器总线读取数据的过程为：发送首地址和读命令需 1 个时钟周期，存储器准备第一个数据需 8 个时钟周期 (即 CAS 潜伏期 = 8)，随后每个时钟周期总线上传送 1 个数据，可连续传送 8 个数据 (即突发长度 = 8)。若主存和 cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 cache 的一次缺失损失至少为多少个时钟周期？()。",
        options: [
            "A. 17",
            "B. 20",
            "C. 33",
            "D. 65"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下是有关虚拟存储管理机制中地址转换的叙述，其中错误的是 ()。",
        options: [
            "A. 地址转换是指把逻辑地址转换为物理地址",
            "B. 通常逻辑地址的位数比物理地址的位数少",
            "C. 地址转换过程中会发现是否 \"缺页\"",
            "D. MMU 在地址转换过程中要访问页表项"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下列命中组合情况中，一次访存过程中不可能发生的是 ()。",
        options: [
            "A. TLB 命中、cache 命中、page 命中",
            "B. TLB 未命中、cache 命中、page 命中",
            "C. TLB 未命中、cache 未命中、page 命中",
            "D. TLB 未命中、cache 命中、page 未命中"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下是有关虚拟存储管理机制中页表的叙述，其中错误的是 ()。",
        options: [
            "A. 系统中每个进程有一个页表",
            "B. 页表中每个表项与一个虚页对应",
            "C. 每个页表项中都包含装入位 (有效位)",
            "D. 所有进程都可以访问页表"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关缺页处理的叙述中，错误的是 ()。",
        options: [
            "A. 若对应页表项中的有效位为 0，则发生缺页",
            "B. 缺页是一种外部中断，需要调用操作系统提供的中断服务程序来处理",
            "C. 缺页处理过程中需根据页表中给出的磁盘地址去读磁盘数据",
            "D. 缺页处理完后要重新执行发生缺页的指令"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关页式存储管理的叙述中，错误的是 ()。",
        options: [
            "A. 进程地址空间被划分成等长的页，内存被划分成同样大小的页框",
            "B. 采用全相联映射，每个页可以映射到任何一个空闲的页框中",
            "C. 当从磁盘装入的信息不足一页时会产生页内碎片",
            "D. 相对于段式存储管理，分页式更有利于保护"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关段式存储管理的叙述中，错误的是 ()。",
        options: [
            "A. 段是逻辑结构上相对独立的程序块，因此段是可变长的",
            "B. 按程序中实际的段来分配主存，所以分配后的存储块是可变长的",
            "C. 每个段表项必须记录对应段在主存的起始位置和段的长度",
            "D. 分段方式对低级语言程序员和编译器来说是透明的"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关快表的叙述中，错误的是 ()。",
        options: [
            "A. 快表的英文缩写是 TLB，称为转换后援缓冲器",
            "B. 快表中存放的是当前进程的常用页表项",
            "C. 在快表中命中时，在 L1 cache 中一定命中",
            "D. 快表是一种高速缓存，一定在 CPU 中"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下给出的事件中，无需异常处理程序进行处理的是 ()。",
        options: [
            "A. 缺页故障",
            "B. cache 缺失",
            "C. 地址越界",
            "D. 除数为 0"
        ],
        answer: "B"
    }
];