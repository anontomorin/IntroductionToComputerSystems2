const questionBank = [
    // 第一章 计算机系统概述（20题）
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关对摩尔定律的描述中，错误的是 ()。",
        options: [
            "A. 每 18 个月，集成电路芯片上集成的晶体管数将翻一番",
            "B. 每 18 个月，集成电路芯片的速度将提高一倍",
            "C. 每 18 个月，集成电路芯片的价格将降低一半",
            "D. 集成电路技术一直会遵循摩尔定律发展下去"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "从计算机的主要元器件来看，计算机发展所经历的过程为 ()。",
        options: [
            "A. 晶体管、电子管、SSI、MSI、LSI、ULSI、VLSI",
            "B. 电子管、晶体管、SSI、MSI、LSI、VLSI、ULSI",
            "C. 电子管、晶体管、LSI、MSI、SSI、VLSI、ULSI",
            "D. 晶体管、电子管、MSI、SSI、LSI、ULSI、VLSI"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "一个完整的计算机系统包括硬件和软件。软件又分为 ()。",
        options: [
            "A. 操作系统和语言处理程序",
            "B. 系统软件和应用软件",
            "C. 操作系统和高级语言",
            "D. 低级语言程序和高级语言程序"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下给出的软件中，属于应用软件的是 ()。",
        options: [
            "A. 汇编程序",
            "B. 编译程序",
            "C. 操作系统",
            "D. 文字处理程序"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下给出的软件中，属于系统软件的是 ()。",
        options: [
            "A. Windows XP",
            "B. MS Word",
            "C. 金山词霸",
            "D. RealPlayer"
        ],
        answer: "A"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关指令集体系结构的说法中，错误的是 ()。",
        options: [
            "A. 指令集体系结构位于计算机软件和硬件的交界面上",
            "B. 指令集体系结构是指低级语言程序员所看到的概念结构和功能特性",
            "C. 程序员可见寄存器的长度、功能与编号不属于指令集体系结构的内容",
            "D. 指令集体系结构的英文缩写是 ISA"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "计算机系统采用层次化结构，从最上面的应用层到最下面的硬件层，其层次化构成为 ()。",
        options: [
            "A. 高级语言虚拟机 - 操作系统虚拟机 - 汇编语言虚拟机 - 机器语言机器",
            "B. 高级语言虚拟机 - 汇编语言虚拟机 - 机器语言机器 - 操作系统虚拟机",
            "C. 高级语言虚拟机 - 汇编语言虚拟机 - 操作系统虚拟机 - 机器语言机器",
            "D. 操作系统虚拟机 - 高级语言虚拟机 - 汇编语言虚拟机 - 机器语言机器"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关程序编写和执行方面的叙述中，错误的是 ()。",
        options: [
            "A. 可用高级语言和低级语言编写出功能等价的程序",
            "B. 高级语言和汇编语言源程序都不能在机器上直接执行",
            "C. 编译程序员必须了解机器结构和指令系统",
            "D. 汇编语言是一种与机器结构无关的编程语言"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "冯・诺依曼计算机中，CPU 区分从存储器取出的是指令还是数据的依据是 ()。",
        options: [
            "A. 指令译码结果的不同",
            "B. 指令和数据的寻址方式的不同",
            "C. 指令和数据的访问阶段的不同",
            "D. 指令和数据所在的存储单元的不同"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关冯・诺依曼计算机结构中指令和数据表示形式的叙述中，正确的是 ()。",
        options: [
            "A. 指令和数据可以从形式上加以区分",
            "B. 指令以二进制形式存放，数据以十进制形式存放",
            "C. 指令和数据都以二进制形式存放",
            "D. 指令和数据都以十进制形式存放"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关计算机中指令和数据存放位置的叙述中，正确的是 ()。",
        options: [
            "A. 指令存放在内存，数据存放在外存",
            "B. 指令和数据任何时候都存放在内存",
            "C. 指令和数据任何时候都存放在外存",
            "D. 程序被启动后，其指令和数据被装入内存"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "冯・诺依曼计算机工作方式的基本特点是 ()。",
        options: [
            "A. 程序一边被输入计算机一边被执行",
            "B. 程序直接从磁盘读到 CPU 执行",
            "C. 按地址访问指令并自动按序执行程序",
            "D. 程序自动执行而数据手工输入"
        ],
        answer: "C"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关冯・诺依曼计算机结构的叙述中，错误的是 ()。",
        options: [
            "A. 计算机由运算器、控制器、存储器和输入 / 输出设备组成",
            "B. 程序由指令和数据构成，存放在存储器中",
            "C. 指令由操作码和地址码两部分组成",
            "D. 指令按地址访问，所有数据在指令中直接给出"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下有关计算机各部件功能的叙述中，错误的是 ()。",
        options: [
            "A. 运算器用来完成算术运算",
            "B. 存储器用来存放指令和数据",
            "C. 控制器通过执行指令来控制整个机器的运行",
            "D. 输入 / 输出设备用来完成用户和计算机之间的信息交换"
        ],
        answer: "A"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "以下给出了改善计算机性能的 4 种措施：①用更快的处理器来替换原来的慢速处理器②增加同类处理器个数，使得不同的处理器同时执行程序③优化编译生成的代码使得程序执行的总时钟周期数减少④减少指令执行过程中访问内存的时间对于某个特定的程序，以上措施中，能缩短其执行时间的措施是 ()。",
        options: [
            "A. 仅①和②和③",
            "B. 仅①和②和④",
            "C. 仅①和③和④",
            "D. 全部"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "若某典型基准测试程序在机器 A 上运行时需要 20s，而在机器 B 上的运行时间是 16s，则相对来说，下面给出的结论中，正确的是 ()。",
        options: [
            "A. 所有程序在机器 A 上都比在机器 B 上运行速度慢",
            "B. 机器 B 的速度是机器 A 的 1.25 倍",
            "C. 机器 A 的速度是机器 B 的 1.25 倍",
            "D. 机器 A 比机器 B 慢 1.25 倍"
        ],
        answer: "B"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "已知计算机 A 的时钟频率为 800MHz，假定某程序在计算机 A 上运行需要 12s。现在硬件设计人员想设计计算机 B，希望该程序在 B 上的运行时间能缩短为 8s，使用新技术后可使 B 的时钟频率大幅度提高，但在 B 上运行该程序所需的时钟周期数为在 A 上的 1.5 倍。那么，机器 B 的时钟频率至少应为多少才能达到所希望的要求？()",
        options: [
            "A. 800MHz",
            "B. 1.2GHz",
            "C. 1.5GHz",
            "D. 1.8GHz"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "假设同一套指令集用不同的方法设计了两种计算机 A 和 B。机器 A 的时钟周期为 1.2ns，机器 B 的时钟周期为 2ns。某个程序在机器 A 上运行时的 CPI 为 2，在 B 上的 CPI 为 1，则对于该程序来说，机器 A 和机器 B 之间的速度关系为 ()。",
        options: [
            "A. 机器 A 比机器 B 快 1.2 倍",
            "B. 机器 B 比机器 A 快 1.2 倍",
            "C. 机器 A 的速度是机器 B 的 12 倍",
            "D. 机器 B 的速度是机器 A 的 1.2 倍"
        ],
        answer: "D"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "假定编译器对高级语言的某条语句可以编译生成两种不同的指令序列，A、B 和 C 三类指令的 CPI 和两种不同序列中所含的三类指令的条数见表 1.1。则以下哪个结论是错误的？()",
        options: [
            "A. 序列一比序列二少 1 条指令",
            "B. 序列一比序列二的执行速度快",
            "C. 序列一的总时钟周期数比序列二多 1 个",
            "D. 序列一的 CPI 比序列二的 CPI 大"
        ],
        answer: "B",
        image: "1.1.png"
    },
    {
        chapter: "第一章 计算机系统概述",
        question: "假定用不同的编译器对同一个程序进行编译生成不同的目标代码指令序列，A、B 和 C 三类指令的 CPI 和两种不同指令序列中所含的三类指令条数见表 1.2。两个指令序列都在时钟周期为 2ns 的机器上运行。根据计算得到其 MIPS 指标和执行速度两方面的结论为 ()。",
        options: [
            "A. 序列一的 MIPS 数比序列二多 50，序列一的执行速度也比序列二快 10s",
            "B. 序列二的 MIPS 数比序列一多 50，但序列一的执行速度比序列二快 10s",
            "C. 序列一的 MIPS 数比序列一多 100，序列一的执行速度也比序列二快 20s",
            "D. 序列二的 MIPS 数比序列一多 100，但序列一的执行速度比序列二快 20s"
        ],
        answer: "B",
        image: "1.2.png"
    },
	// 第二章 数据的机器级表示与处理（58题）
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "计算机中的所有信息都以二进制表示的原因是 ()。",
        options: [
            "A. 信息处理方便",
            "B. 运算速度快",
            "C. 节约元器件",
            "D. 物理器件特性所致"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "引入八进制和十六进制的目的是 ()。",
        options: [
            "A. 节约元件",
            "B. 实现方便",
            "C. 可以表示更大范围的数",
            "D. 用于等价地表示二进制，便于阅读和书写"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "108对应的十六进制形式为()。",
        options: [
            "A. 6CH",
            "B. B4H",
            "C. 5CH",
            "D. 63H"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下给出的各种进位计数制的数中，最小的数为 ()。",
        options: [
            "A. (10010110)₂",
            "B. (63)₈",
            "C. (1001 0110) BCD",
            "D. (2F)₁₆"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下给出的各种进位计数制的数中，最小的数为 ()。",
        options: [
            "A. (1110 0101)₂",
            "B. (93)₁₀",
            "C. (1001 0010) BCD",
            "D. (5A)₁₆"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "负零的补码表示为 ()。",
        options: [
            "A. 100...00",
            "B. 000...00",
            "C. 011...11",
            "D. 111...11"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "[X] 补 = X₀・X₁X₂...Xₙ（n 为整数），它的模是 ()。",
        options: [
            "A. 2ⁿ⁻¹",
            "B. 2ⁿ",
            "C. 1",
            "D. 2"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "[X] 补 = X₀X₁X₂...Xₙ（n 为整数），它的模是 ()。",
        options: [
            "A. 2ⁿ⁺¹",
            "B. 2ⁿ",
            "C. 2ⁿ+1",
            "D. 2ⁿ-1"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下编码中，零的表示形式是唯一的编码是 ()。",
        options: [
            "A. 反码",
            "B. 原码",
            "C. 补码",
            "D. 原码和补码"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下有关补码和移码（偏置常数为 2ⁿ⁻¹）关系的叙述中，错误的是 ()。",
        options: [
            "A. 相同位数的补码和移码表示具有相同的表数范围",
            "B. 零的补码和移码表示相同",
            "C. 同一个数的补码和移码表示，其数值部分相同，而符号相反",
            "D. 一般用移码表示浮点数的阶，而用补码表示定点整数"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下是一些关于编码表示特点的叙述：①零的表示是唯一的。②符号位可以和数值部分一起参加运算。③和其真值的对应关系简单、直观。④减法可用加法来实现。其中哪些选项是补码表示的特点？()",
        options: [
            "A. 仅①和②",
            "B. 仅①和③",
            "C. 仅①和②和③",
            "D. 仅①和②和④"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定某数 X=-01001010B，在计算机内部的表示为 10110110B，则该数所用的编码方法是 ()。",
        options: [
            "A. 原码",
            "B. 反码",
            "C. 补码",
            "D. 移码"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设寄存器位数为 8 位，机器数采用补码形式（含一位符号位），则十进制数 - 26 存放在寄存器中的内容为 ()。",
        options: [
            "A. 26H",
            "B. 9BH",
            "C. E6H",
            "D. 5AH"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "-1029 的 16 位补码用十六进制表示为 ()。",
        options: [
            "A. 0405H",
            "B. 7BFBH",
            "C. 8405H",
            "D. FBFBH"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "考虑以下 C 语言代码：short si= -8196; unsigned short usi=si; 执行上述程序段后，usi 的值是 ()。",
        options: [
            "A. 8196",
            "B. 34572",
            "C. 57339",
            "D. 57340"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若 [X] 原 = 1.x₁x₂x₃x₄，其中，小数点前面一位是符号位，符号位为 1 时表示负数。当满足 () 时，X>-1/2 成立。",
        options: [
            "A. x₁必须为 1，x₂、x₃、x₄至少有一个为 1",
            "B. x₁必须为 1，x₂、x₃、x₄任意",
            "C. x₁必须为 0，x₂、x₃、x₄至少有一个为 1",
            "D. x₁必须为 0，x₂、x₃、x₄任意"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "设 X=-1011，则 8 位补码 [X] 补为 ()。",
        options: [
            "A. 1000 0101",
            "B. 1000 1011",
            "C. 1111 0101",
            "D. 1111 1011"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "16 位无符号数所能表示的数值范围是 ()。",
        options: [
            "A. 0~(2¹⁶-1)",
            "B. 0~(2¹⁵-1)",
            "C. 0~2¹⁶",
            "D. 0~2¹⁵"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "16 位补码整数所能表示的范围是 ()。",
        options: [
            "A. -2¹⁵~+(2¹⁵-1)",
            "B. -(2¹⁵-1)~+(2¹⁵-1)",
            "C. -2¹⁶~+(2¹⁶-1)",
            "D. -(2¹⁶-1)~+(2¹⁶-1)"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若浮点数尾数用补码表示，则下列数中为规格化尾数形式的是 ()。",
        options: [
            "A. 1.110 0000",
            "B. 0.011 1000",
            "C. 0.010 1000",
            "D. 1.000 1000"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若浮点数尾数用原码表示，则下列数中为规格化尾数形式的是 ()。",
        options: [
            "A. 1.110 0000",
            "B. 0.011 1000",
            "C. 0.010 1000",
            "D. 1.000 1000"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "用于表示浮点数阶码的编码通常是 ()。",
        options: [
            "A. 原码",
            "B. 补码",
            "C. 反码",
            "D. 移码"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定某数采用 IEEE754 单精度浮点数格式表示为 45100000H，则该数的值是 ()。",
        options: [
            "A. (+1.125)₁₀×2¹⁰",
            "B. (+1.125)₁₀×2¹¹",
            "C. (+0.125)₁₀×2¹¹",
            "D. (+0.125)₁₀×2¹⁰"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定某数采用 IEEE754 单精度浮点数格式表示为 C8200000H，则该数的值是 ()。",
        options: [
            "A. (-1.01)₁₀×2¹⁷",
            "B. (-1.01)₁₀×2¹⁴⁴",
            "C. (-1.25)₁₀×2¹⁷",
            "D. (-1.25)₁₀×2¹⁴⁴"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定变量 i、f 的数据类型分别是 int、float。已知 i=12345，f=1.2345e3，则在一个 32 位机器中执行下列表达式时，结果为 \"假\" 的是 ()。",
        options: [
            "A. i==(int)(float) i",
            "B. i==(int)(double) i",
            "C. f==(float)(int) f",
            "D. f==(float)(double) f"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IBM370 的短浮点数格式中，总位数为 32 位，左边第一位 (b₀) 为数符，随后 7 位 (b₁~b₇) 为阶码，用移码表示，偏置常数为 64，右边 24 位 (b₈~b₃₁) 为 6 位十六进制原码小数表示的尾数，规格化尾数形式为 0.x₁x₂x₃x₄x₅x₆，x₁~x₆为十六进制表示，最高位 x₁为非 0 数，基为 16。若将十进制数 - 265.625 用该浮点数规格化形式表示，则应表示为 ()。(用十六进制形式表示)",
        options: [
            "A. C310 9A00H",
            "B. 4310 9A00H",
            "C. 8310 9A00H",
            "D. 0310 9A00H"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定两种浮点数表示格式的位数都是 32 位，但格式 1 的阶码长、尾数短，格式 2 的阶码短、尾数长，其他所有规定都相同。则它们可表示的数的精度和范围为 ()。",
        options: [
            "A. 两者可表示的数的范围和精度均相同",
            "B. 格式 1 可表示的数的范围更小，但精度更高",
            "C. 格式 2 可表示的数的范围更小，但精度更高",
            "D. 格式 1 可表示的数的范围更大，且精度更高"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "在一般的计算机系统中，西文字符编码普遍采用 ()。",
        options: [
            "A. BCD 码",
            "B. ASCII 码",
            "C. 格雷码",
            "D. CRC 码"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定某计算机按字节编址，采用小端方式，有一个 float 型变量 x 的地址为 FFFF C000H，x=12345678H，则在内存单元 FFFF C001H 中存放的内容是 ()。",
        options: [
            "A. 1234H",
            "B. 34H",
            "C. 56H",
            "D. 5678H"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下有关机器字长的叙述中，错误的是 ()。",
        options: [
            "A. 机器字长是指 CPU 中定点运算数据通路宽度",
            "B. 机器字长一般与 CPU 中寄存器的位数有关",
            "C. 机器字长决定了定点整数的表示范围",
            "D. 机器字长对计算机硬件的造价没有影响"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "以下关于计算机中存储器容量单位的叙述中，错误的是 ()。",
        options: [
            "A. 最小的计量单位为位 (bit)，表示一位 \"0\" 或 \"1\"",
            "B. 最基本的计量单位是字节",
            "C. 一台计算机的编址单位、指令字长和数据字长都一样，且是字节的整数倍",
            "D. 主存容量为 1KB，其含义是主存中能存放 1024 个字节的二进制信息"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定下列字符编码中含有奇偶检验位，但没有发生数据错误，那么采用奇校验的字符编码是 ()。",
        options: [
            "A. 01010011",
            "B. 0110 0110",
            "C. 1011 0000",
            "D. 0011 0101"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "8 位无符号整数 10010101 右移一位后的值为 ()。",
        options: [
            "A. 01001010",
            "B. 01001011",
            "C. 10001010",
            "D. 1100 101"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "8 位补码定点整数 10010101 右移一位后的值为 ()。",
        options: [
            "A. 0100 1010",
            "B. 01001011",
            "C. 1000 1010",
            "D. 11001010"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "8 位补码定点整数 10010101 左移一位后的值为 ()。",
        options: [
            "A. 1010 1010",
            "B. 00101010",
            "C. 00101011",
            "D. 溢出"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "8 位补码定点整数 10010101 扩展 8 位后的值用十六进制表示为 ()。",
        options: [
            "A. 0095H",
            "B. 9500H",
            "C. FF95H",
            "D. 95FFH"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "原码定点小数 1.10010101 扩展 8 位后的值为 ()。",
        options: [
            "A. 1.00000000 1001 0101",
            "B. 1.1001 0101 00000000",
            "C. 1.1111 1111 10010101",
            "D. 1.1001 0101 11111111"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "考虑以下 C 语言代码：short si= -8196; int i=si; 执行上述程序段后，i 的机器数表示为 ()。",
        options: [
            "A. 0000 9FFCH",
            "B. 0000DFFCH",
            "C. FFFF 9FFCH",
            "D. FFFF DFFCH"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "CPU 中能进行算术和逻辑运算的最基本运算部件是 ()。",
        options: [
            "A. 多路选择器",
            "B. 移位器",
            "C. 加法器",
            "D. ALU"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "ALU 的核心部件是 ()。",
        options: [
            "A. 多路选择器",
            "B. 移位器",
            "C. 加法器",
            "D. 寄存器"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "在补码加 / 减运算部件中，无论采用双符号位还是单符号位，必须有 () 电路，它一般用异或门来实现。",
        options: [
            "A. 译码",
            "B. 编码",
            "C. 溢出判断",
            "D. 移位"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知无符号数 x=69，y=38，现要在该加法器中完成 x+y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为 ()。",
        options: [
            "A. 0100 0101、0010 0110、0",
            "B. 01000101、00100110、1",
            "C. 0100 0101、1101 1010、0",
            "D. 01000101、11011010、1"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知无符号数 x=69，y=38，现要在该加法器中完成 x-y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为 ()。",
        options: [
            "A. 0100 0101、0010 0110、0",
            "B. 0100 0101、11011001、1",
            "C. 0100 0101、1101 1010、0",
            "D. 01000101、11011010、1"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知带符号整数 x=-69，y=-38，现要在该加法器中完成 x+y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为 ()。",
        options: [
            "A. 10111011、1101 1010、0",
            "B. 1011 1011、1101 1010、1",
            "C. 1011 1011、00100101、0",
            "D. 10111011、00100101、1"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某计算机字长为 8 位，其 CPU 中有一个 8 位加法器。已知带符号整数 x=-69，y=-38，现要在该加法器中完成 x-y 的运算，则该加法器的两个输入端信息和输入的低位进位信息分别为 ()。",
        options: [
            "A. 1011 1011、11011010、0",
            "B. 1011 1011、1101 1010、1",
            "C. 10111011、00100101、1",
            "D. 1011 1011、00100110、1"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，x=63，y=-31，则 x+y 的机器数及其相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. 1FH、0",
            "B. 20H、0",
            "C. 1FH、1",
            "D. 20H、1"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，x=63，y=-31，则 x-y 的机器数及其相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. 5DH、0",
            "B. 5EH、0",
            "C. 5DH、1",
            "D. 5EH、1"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定带符号整数变量 x 和 y 的机器数用补码表示，[x] 补 = F5H，[y] 补 = 7EH，则 x+y 的值及其相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. 115、0",
            "B. 119、0",
            "C. 115、1",
            "D. 119、1"
        ],
        answer: "A"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定带符号整数变量 x 和 y 的机器数用补码表示，[x] 补 = F5H，[y] 补 = 7EH，则 x-y 的值及其相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. 115、0",
            "B. 119、0",
            "C. 115、1",
            "D. 119、1"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，[x] 补 = 44H，[y] 补 = DCH，则 x+2y 的机器数以及相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. 32H、0",
            "B. 32H、1",
            "C. FCH、0",
            "D. FCH、1"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，[x] 补 = 44H，[y] 补 = DCH，则 x-2y 的机器数以及相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. 68H、0",
            "B. 68H、1",
            "C. 8CH、0",
            "D. 8CH、1"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "某 8 位计算机中，假定 x 和 y 是两个带符号整数变量，用补码表示，[x] 补 = 44H，[y] 补 = DCH，则 x/2+2y 的机器数以及相应的溢出标志 OF 分别是 ()。",
        options: [
            "A. CAH、0",
            "B. CAH、1",
            "C. DAH、0",
            "D. DAH、1"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "假定有两个整数用 8 位补码分别表示为 r1=F5H，r2=EEH。若将运算结果存放在一个 8 位寄存器中，则下列运算中会发生溢出的是 ()。",
        options: [
            "A. r1+r2",
            "B. r1-r2",
            "C. r1×r2",
            "D. r1/r2"
        ],
        answer: "C"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "对于 IEEE754 单精度浮点加减运算，在对阶过程中，需计算两个阶码 Ex 和 Ey 之差的补码 [ΔE] 补。若 ΔE≥128 或 ΔE≤-129，则 [ΔE] 补发生溢出。假定 [Ex] 移、[-[Ey] 移] 补和 [ΔE] 补的最高有效位分别记为 Exs、Eys 和 Ebs，则相应的溢出判断方程为 ()。",
        options: [
            "A. ",
            "B. ",
            "C. ",
            "D. "
        ],
        answer: "D",
		image:"2.1.png"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IEEE754 单精度浮点数加减运算的对阶过程中，需要计算两个阶码 Ex 和 Ey 之差的补码 [ΔE] 补。假设两个浮点数分别记为 [x] 浮和 [y] 浮，[Ex] 移、[Ey] 移和 [ΔE] 补的最高有效位分别记为 Exs、Eys 和 Ebs，当 [ΔE] 补发生溢出时，正确的处理方式是 ()。",
        options: [
            "A. 中止当前程序的执行，调出相应的 \"溢出\" 异常处理程序执行",
            "B. 当 Exs 为 1 时置最终结果为 [x] 浮；当 Exs 为 0 时置最终结果为 [y] 浮",
            "C. 当 Eys 为 1 时置最终结果为 [x] 浮；当 Eys 为 0 时置最终结果为 [y] 浮",
            "D. 当 Ebs 为 0 时置最终结果为 [x] 浮；当 Ebs 为 1 时置最终结果为 [y] 浮"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "若两个 float 型变量（用 IEEE754 单精度浮点格式表示）x 和 y 的机器数分别表示为 x=40E80000H，y=C2040000H，则在计算 x+y 时，第一步对阶操作的结果 [ΔE] 补为 ()。",
        options: [
            "A. 0000 0111",
            "B. 0000 0011",
            "C. 11111011",
            "D. 11111101"
        ],
        answer: "D"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "对于 IEEE754 单精度浮点数加减运算，只要对阶时得到的两个阶码之差的绝对值 |ΔE | 大于等于 ()，就无需继续进行后续处理，此时，运算结果直接取阶大的那个数。",
        options: [
            "A. 24",
            "B. 25",
            "C. 126",
            "D. 128"
        ],
        answer: "B"
    },
    {
        chapter: "第二章 数据的机器级表示与处理",
        question: "IEEE754 标准提供了以下 4 种舍入模式，其中平均误差最小的是 ()。",
        options: [
            "A. 就近舍入 (中间值时强迫为偶数)",
            "B. 正向舍入 (即朝 +∞方向舍入)",
            "C. 负向舍入 (即朝 -∞方向舍入)",
            "D. 截断舍入 (即朝 0 方向舍入)"
        ],
        answer: "A"
    },
   
    // 第三章 程序的转换及机器级表示（78题）
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关指令的叙述中，错误的是 ()。",
        options: [
            "A. 机器指令是用二进制表示的一个 0/1 序列，CPU 能直接执行",
            "B. 汇编指令是机器指令的符号表示，CPU 能直接执行",
            "C. 伪指令是由若干条机器指令构成的一个指令序列，属于软件范畴",
            "D. 微指令是一条机器指令所包含的控制信号的组合，CPU 能直接执行"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "一条机器指令通常由多个字段构成。以下选项中，() 不显式地包含在机器指令中。",
        options: [
            "A. 操作码",
            "B. 寻址方式",
            "C. 下条指令地址",
            "D. 寄存器编号"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "对于运算类指令或传送类指令，通常需要在指令中指出操作数或操作数所在的位置。通常，指令中指出的操作数不可能出现在 () 中。",
        options: [
            "A. 指令",
            "B. 通用寄存器",
            "C. 存储单元",
            "D. 程序计数器"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "指令集体系结构 (ISA) 是计算机系统中必不可少的一个抽象层，它是对硬件的抽象，软件通过它所规定的指令系统规范来使用硬件。以下有关 ISA 的叙述中，错误的是 ()。",
        options: [
            "A. ISA 规定了所有指令的集合，包括指令格式和操作类型",
            "B. ISA 规定了执行每条指令时所包含的控制信号",
            "C. ISA 规定了指令获取操作数的方式，即寻址方式",
            "D. ISA 规定了指令的操作数类型、寄存器结构、存储空间大小、编址方式和大端 / 小端方式"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下选项中，不属于指令集体系结构名称的是 ()。",
        options: [
            "A. UNIX",
            "B. IA-32",
            "C. ARM",
            "D. MIPS"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下 Intel 微处理器中，不兼容 IA-32 指令集体系结构的是 ()。",
        options: [
            "A. 80386 和 80486",
            "B. Pentium (Ⅱ、Ⅲ、4)",
            "C. Core (i3、i5、i7)",
            "D. Itanium 和 Itanium 2"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 IA-32 指令格式的叙述中，错误的是 ()。",
        options: [
            "A. 采用变长指令字格式，指令长度从一个字节到十几个字节不等",
            "B. 采用变长操作码，操作码位数可能是 5 位到十几位不等",
            "C. 指令中指出的位移量和立即数的长度可以是 0、1、2 或 4 个字节",
            "D. 指令中给出的操作数所在的通用寄存器的宽度总是 32 位"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 IA-32 指令寻址方式的叙述中，错误的是 ()。",
        options: [
            "A. 操作数可以是指令中的立即数，也可以是通用寄存器或存储单元中的内容",
            "B. 对于寄存器操作数，必须在指令中给出通用寄存器的 3 位编号",
            "C. 存储器操作数中最复杂的寻址方式是 \"基址加比例变址加位移\"",
            "D. 相对寻址的目标地址为 \"PC 内容加位移\"，PC 内容指当前正在执行指令的地址"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 IA-32 中整数运算指令所支持的操作数的叙述中，错误的是 ()。",
        options: [
            "A. 对于加减运算指令，操作数不区分是无符号整数还是带符号整数",
            "B. 对于乘除运算指令，操作数一定区分是无符号整数还是带符号整数",
            "C. 除乘法指令外，其他运算指令的源操作数和目的操作数的位数相等",
            "D. 参加运算的操作数可以是一个字节 (8b)、一个字 (16b) 或双字 (32b)"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 IA-32 的定点寄存器组织的叙述中，错误的是 ()。",
        options: [
            "A. 每个通用寄存器都可作为 32 位、16 位或 8 位寄存器使用",
            "B. 寄存器 EAX/AX/AL 称为累加器，ECX/CX/CL 称为计数寄存器",
            "C. 寄存器 ESP/SP 称为栈指针寄存器，EBP/BP 称为基址指针寄存器",
            "D. EIP/IP 为指令指针寄存器，即 PC；EFLAGS/FLAGS 为标志寄存器"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某 C 语言程序中对数组变量 b 的声明为 \"int b [10][5];\"，有一条 for 语句如下：for (i=0;i<10;i++) for (j=0;j<5;j++) sum+=b [i][j]; 假设执行到 \"sum+=b [i][j];\" 时，sum 的值在 EAX 中，b [i][0] 所在的地址在 EDX 中，j 在 ESI 中，则 \"sum+=b [i][j];\" 所对应的指令 (AT&T 格式) 可以是 ()。",
        options: [
            "A. addl 0 (% edx, % esi, 4), % eax",
            "B. addl 0 (% esi, % edx, 4), % eax",
            "C. addl 0 (% edx, % esi, 2), % eax",
            "D. addl 0 (% esi, % edx, 2), % eax"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "IA-32 中指令 \"pushl % ebp\" 的功能是 ()。",
        options: [
            "A. R [esp] ← R [esp]-4, M [R [esp]] ← R [ebp]",
            "B. R [esp] ← R [esp]+4, M [R [esp]] ← R [ebp]",
            "C. M [R [esp]] ← R [ebp], R [esp] ← R [esp]-4",
            "D. M [R [esp]] ← R [ebp], R [esp] ← R [esp]+4"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "IA-32 中指令 \"popl % ebp\" 的功能是 ()。",
        options: [
            "A. R [esp]←R [esp]-4, R [ebp] ← M [R [esp]]",
            "B. R [esp] ← R [esp]+4, R [ebp] ← M [R [esp]]",
            "C. R [ebp] ← M [R [esp]], R [esp] ← R [esp]-4",
            "D. R [ebp] ← M [R [esp]], R [esp] ← R [esp]+4"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "IA-32 中指令 \"movl 8 (% ebp),% edx\" 的功能是 ()。",
        options: [
            "A. M [R [ebp]+8] ← R [edx]",
            "B. R [edx] ← M [R [ebp]+8]",
            "C. R [ebp]+8 ← R [edx]",
            "D. R [edx] ← R [ebp]+8"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "IA-32 中指令 \"movl 8 (% edx,% esi,4),% edx\" 的功能是 ()。",
        options: [
            "A. M [R [edx]+R [esi]*4+8] ← R [edx]",
            "B. M [R [esi]+R [edx]*4+8] ← R [edx]",
            "C. R [edx] ← M [R [edx]+R [esi]*4+8]",
            "D. R [edx] ← M [R [esi]+R [edx]*4+8]"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "IA-32 中指令 \"leal 8 (% edx,% esi,4),% edx\" 的功能是 ()。",
        options: [
            "A. R [edx]+R [esi]*4+8 ← R [edx]",
            "B. R [esi]+R [edx]*4+8 ← R [edx]",
            "C. R [edx] ← R [edx]+R [esi]*4+8",
            "D. R [edx] ← R [esi]+R [edx]*4+8"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "设 SignExt [x] 表示对 x 符号扩展，ZeroExt [x] 表示对 x 零扩展。IA-32 中指令 \"movswl % cx, -20 (% ebp)\" 的功能是 ()。",
        options: [
            "A. M [R [ebp]-20] ← SignExt [R [cx]]",
            "B. R [cx] ← SignExt [M [R [ebp]-20]]",
            "C. M [R [ebp]-20] ← ZeroExt [R [cx]]",
            "D. R [cx] ← ZeroExt [M [R [ebp]-20]]"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 R [ax]=FFE8H，R [bx]=7FE6H，执行指令 \"addw % bx, % ax\" 后，寄存器的内容和各标志的变化为 ()。",
        options: [
            "A. R [ax]=7FCEH, OF=1, SF=0, CF=0, ZF=0",
            "B. R [bx]=7FCEH, OF=1, SF=0, CF=0, ZF=0",
            "C. R [ax]=7FCEH, OF=0, SF=0, CF=1, ZF=0",
            "D. R [bx]=7FCEH, OF=0, SF=0, CF=1, ZF=0"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 R [ax]=FFE8H，R [bx]=7FE6H，执行指令 \"subw % bx,% ax\" 后，寄存器的内容和各标志的变化为 ()。",
        options: [
            "A. R [ax]=8002H, OF=0, SF=1, CF=0, ZF=0",
            "B. R [bx]=8002H, OF=0, SF=1, CF=0, ZF=0",
            "C. R [ax]=8002H, OF=1, SF=1, CF=0, ZF=0",
            "D. R [bx]=8002H, OF=1, SF=1, CF=0, ZF=0"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 R [eax]=000001B6H，R [ebx]=00FF0110H，执行指令 \"mulw % bx\" 后，寄存器的内容变为 ()。",
        options: [
            "A. R [eax]=0000B600H, R [dx]=0001H",
            "B. R [eax]=0000D160H, R [dx]=0001H",
            "C. R [eax]=0000D160H, R [bx]=0001H",
            "D. R [eax]=0001D160H, 其余不变"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 R [eax]=0000B160H，R [ebx]=00FF0110H，执行指令 \"imulw % bx\" 后，寄存器的内容变为 ()。",
        options: [
            "A. R [eax]=00007600H, R [dx]=00BCH",
            "B. R [eax]=00007600H, R [dx]=FFACH",
            "C. R [eax]=FFAC7600H, 其余不变",
            "D. R [eax]=00BC7600H, 其余不变"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 R [eax]=080480B4H，R [ebx]=00000011H，M [080480F8H]=000000B0H，执行指令 \"imull $-16, (% eax,% ebx,4),% eax\" 后，寄存器的内容和存储单元内容变为 ()。",
        options: [
            "A. R [eax]=00000B00H",
            "B. M [080480F8H]=00000B00H",
            "C. R [eax]=FFFFFF500H",
            "D. M [080480F8H]=FFFFF500H"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 R [eax]=FF000008H，R [ecx]=00001000H，执行指令 \"testl % eax,% ecx\" 后，寄存器的内容和标志变为 ()。",
        options: [
            "A. R [ecx]=00000000H, OF=CF=SF=0, ZF=1",
            "B. R [eax]=00000000H, OF=CF=SF=0, ZF=1",
            "C. R [ecx]=00000000H, 标志不变",
            "D. 寄存器内容不变，OF=CF=SF=0, ZF=1"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 short 型变量 x 被分配在寄存器 AX 中，若 R [ax]=FF70H，则执行指令 \"salw $2, % ax\" 后，变量 x 的机器数和真值分别是 ()。",
        options: [
            "A. FDCOH,-576",
            "B. FFDCH,-36",
            "C. FDC3H,-573",
            "D. 3FDC,16348"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "程序 P 中有两个 unsigned 类型变量 i 和 j，被分别分配在寄存器 EAX 和 EDX 中，P 中存在以下 if 语句：if (i<j){...} 该 if 语句对应的指令序列一定不会是 ()。",
        options: [
            "A. cmpl % eax, % edx; jbe 804847c",
            "B. cmpl % edx, % eax; jb 8048460",
            "C. cmpl % eax, % edx; ja 8048380",
            "D. cmpl % eax, % edx; jae 8048480"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "程序 P 中有两个 int 类型变量 i 和 j，被分别分配在寄存器 EAX 和 EDX 中，P 中存在以下 if 语句：if (i<j){...} 该 if 语句对应的指令序列一定不会是 ()。",
        options: [
            "A. cmpl % eax, % edx; jle 804847c",
            "B. cmpl % edx, % eax; jl 8048460",
            "C. cmpl % eax, % edx; ja 8048380",
            "D. cmpl % eax, % edx; jg 8048480"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "程序 P 中有两个变量 i 和 j，被分别分配在寄存器 EAX 和 EDX 中，P 中语句 \"if (i<j) {...}\" 对应的指令序列如下 (左边为指令地址，中间为机器代码，右边为汇编指令)：804846a: 39 c2 cmpl % eax, % edx 804846c: 7e 0d jle XXXXXXXX 若执行到 804846a 处的 cmpl 指令时，i=105，j=100，则 jle 指令执行后将会转到 () 处的指令执行。",
        options: [
            "A. 8048461",
            "B. 804846e",
            "C. 8048479",
            "D. 804847b"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于各类控制转移指令的叙述中，错误的是 ()。",
        options: [
            "A. 无条件转移指令 (JMP) 直接将转移目标地址送到 EIP 寄存器中",
            "B. 条件转移指令 (Jcc) 将根据 EFLAGS 寄存器中的标志信息进行条件判断",
            "C. 条件转移指令 (Jcc) 的判断条件可用于整数之间和浮点数之间的大小比较",
            "D. 调用指令 (CALL) 和返回指令 (RET) 都是特殊的无条件转移指令"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 x87 FPU 浮点处理指令系统的叙述中，错误的是 ()。",
        options: [
            "A. 提供 80 位浮点运算功能",
            "B. float、double 和 long double 三种类型数据都按 80 位格式存放在浮点寄存器中",
            "C. float、double 和 long double 型数据存入主存时，分别占 32 位、64 位和 96 位",
            "D. float 和 double 型数据从主存装入浮点寄存器时有可能发生舍人，造成精度损失"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 MMX/SSE 指令集的叙述中，错误的是 ()。",
        options: [
            "A. 同一个微处理器同时支持 IA-32 指令集与 MMX/SSE 指令集",
            "B. MMX/SSE 指令集和 IA-32 指令集共用同一套通用寄存器",
            "C. SSE 指令是一种采用 SIMD (单指令多数据) 技术的数据级并行指令",
            "D. 目前 SSE 支持 128 位整数运算或同时并行处理两个 64 位双精度浮点数"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 P 为调用过程，Q 为被调用过程，程序在 IA-32 处理器上执行，以下有关过程调用的叙述中，错误的是 ()。",
        options: [
            "A. C 语言程序中的函数调用就是过程调用",
            "B. 从 P 传到 Q 的实参无需重新分配空间存放",
            "C. 从 P 跳转到 Q 执行应使用 CALL 指令",
            "D. 从 Q 跳回到 P 执行应使用 RET 指令"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假设 P 为调用过程，Q 为被调用过程，程序在 IA-32 处理器上执行，以下是 C 语言程序中过程调用所涉及的操作：①过程 Q 保存 P 的现场，并为非静态局部变量分配空间 ②过程 P 将实参存放到 Q 能访问到的地方 ③过程 P 将返回地址存放到特定处，并跳转到 Q 执行 ④过程 Q 取出返回地址，并跳转回到过程 P 执行 ⑤过程 Q 恢复 P 的现场，并释放局部变量所占空间 ⑥执行过程 Q 的函数体 过程调用的正确执行步骤是 ()。",
        options: [
            "A. ②→③→④→①→⑤→⑥",
            "B. ②→③→①→④→⑥→⑤",
            "C. ②→③→①→⑥→⑤→④",
            "D. ②→③→①→⑤→⑥→④"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 IA-32 的过程调用方式的叙述中，错误的是 ()。",
        options: [
            "A. 入口参数使用栈 (stack) 传递，即所传递的实参被分配在栈中",
            "B. 返回地址是 CALL 指令下一条指令的地址，被保存在栈中",
            "C. EAX、ECX 和 EDX 都是调用者保存寄存器",
            "D. EBX、ESI、EDI、EBP 和 ESP 都是被调用者保存寄存器"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 IA-32/Linux 的过程调用的叙述中，错误的是 ()。",
        options: [
            "A. 在过程中通常先使用被调用者保存寄存器",
            "B. 每个过程都有一个栈帧，其大小为 16B 的倍数",
            "C. 通常 EBP 寄存器指向对应栈帧 (stack frame) 的底部",
            "D. 通常每个栈帧底部单元中存放其调用过程的 EBP 内容"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 IA-32 的过程调用所使用的栈和栈帧的叙述中，错误的是 ()。",
        options: [
            "A. 每进行一次过程调用，用户栈从高地址向低地址增长",
            "B. 从被调用过程返回调用过程之前，被调用过程会释放自己的栈帧",
            "C. 只能通过将栈指针 ESP 作为基址寄存器来访问用户栈中的数据",
            "D. 过程嵌套调用深度越深，栈中栈帧个数越多，严重时会发生栈溢出"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 C 语言程序的变量的作用域和生存期的叙述中，错误的是 ()。",
        options: [
            "A. 静态 (static 型) 变量和非静态局部 (auto 型) 变量都分配在对应栈帧中",
            "B. 因为非静态局部变量被分配在栈中，所以其作用域仅在过程体内",
            "C. 非静态局部变量可以和全局变量同名，是因为它们被分配在不同存储区",
            "D. 不同过程中的非静态局部变量可以同名，是因为它们被分配在不同栈帧中"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下是一段 C 语言程序代码：1 int add (int x,int y) { 2 return x+y; 3 } 4 5 int caller () { 6 7 int t1=100; int t2=200; int sum=add (t1,t2); 8 9 return sum; 10 } 以下关于上述程序代码在 IA-32 上执行的叙述中，错误的是 ()。",
        options: [
            "A. 变量 t1 和 t2 被分配在 caller 函数的栈帧中",
            "B. 传递参数时 t1 和 t2 的值从高地址到低地址依次存入栈中",
            "C. add 函数返回时返回值存放在 EAX 寄存器中",
            "D. 变量 sum 被分配在 caller 函数的栈帧中"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "第 37 题中的 caller 函数对应的机器级代码如下：1 pushl % ebp 2 movl % esp, % ebp 3 subl $16, %esp 4 movl $100, -12 (% ebp) 5 movl $200, -8 (% ebp) 6 movl -8 (% ebp), % eax 7 movl % eax, 4 (% esp) 8 movl -12 (% ebp), % eax 9 movl % eax, (% esp) 10 call add 11 movl % eax, -4 (% ebp) 12 movl -4 (% ebp), % eax 13 leave 14 ret 假定 caller 的调用过程为 P，对于上述指令序列，以下叙述中错误的是 ()。",
        options: [
            "A. 第 1 条指令将过程 P 的 EBP 内容压入 caller 栈帧",
            "B. 第 2 条指令使 EBP 内容指向caller栈帧的底部",
            "C. 第 3 条指令将栈指针 ESP 向高地址方向移动，以生成当前栈帧",
            "D. 从上述指令序列可看出，caller 函数没有使用被调用者保存寄存器"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "对于第 37 题的 caller 函数以及第 38 题给出的对应机器级代码，以下叙述中错误的是 ()。",
        options: [
            "A. 变量 t1 和 t2 的有效地址分别为 R [ebp]-12 和 R [ebp]-8",
            "B. 变量 t1 所在的地址高 (或大) 于变量 t2 所在的地址",
            "C. 参数 t1 和 t2 的有效地址分别为 R [esp] 和 R [esp]+4",
            "D. 参数 t1 所在的地址低 (或小) 于参数 t2 所在的地址"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "对于第 37 题的 caller 函数以及第 38 题给出的对应机器级代码，以下叙述中错误的是 ()。",
        options: [
            "A. 执行第 10 条指令的过程中，将会把第 11 条指令的地址压入栈顶",
            "B. 执行第 11 条指令时，add 函数的返回值已经在 EAX 寄存器中",
            "C. 变量 sum 的有效地址为 R [ebp]-4",
            "D. leave 指令用于恢复 EBP 的旧值，并不会改变 ESP 的内容"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关递归过程调用的叙述中，错误的是 ()。",
        options: [
            "A. 可能需要执行递归过程很多次，因而时间开销大",
            "B. 每次递归调用都会生成一个新的栈帧，因而空间开销大",
            "C. 每次递归调用在栈帧中保存的返回地址都不相同",
            "D. 递归过程第一个参数的有效地址为 R [ebp]+8"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 if (cond_expr) then_statement else else_statement 选择结构对应的机器级代码表示的叙述中，错误的是 ()。",
        options: [
            "A. 一定包含一条无条件转移指令",
            "B. 一定包含一条条件转移指令 (分支指令)",
            "C. 计算 cond_expr 的代码段一定在条件转移指令之前",
            "D. 对应 then_statement 的代码一定在对应 else_statement 的代码之前"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 switch 语句的机器级代码表示的叙述中，错误的是 ()。",
        options: [
            "A. 当 case 中出现的条件取值范围较小时，可以用跳转表的方式实现",
            "B. 每个 case 至少对应一条条件转移指令，因而一定会包含多条条件转移指令",
            "C. 每个 case 对应的一段代码结束后，都会有一条无条件转移指令",
            "D. 可以用连续的 if~else~if~else~if... 语句对应的机器代码来实现 switch 语句"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于循环结构语句的机器级代码表示的叙述中，错误的是 ()。",
        options: [
            "A. 一定至少包含一条条件转移指令",
            "B. 不一定包含无条件转移指令",
            "C. 循环结束条件通常用一条比较指令 CMP 来实现",
            "D. 循环体内执行的指令不包含条件转移指令"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定全局 short 型数组 a 的起始地址为 0x804908c，则 a [2] 的地址是 ()。",
        options: [
            "A. 0x804908e",
            "B. 0x8049090",
            "C. 0x8049092",
            "D. 0x8049094"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定全局 double 型数组 a 的起始地址为 0x804908c，则 a [i] 的地址是 ()。",
        options: [
            "A. 0x804908c+i",
            "B. 0x804908c+2×i",
            "C. 0x804908c+4×i",
            "D. 0x804908c+8×i"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定全局数组 a 的声明为 char* a [8]，a 的首地址为 0x80498c0，i 在 ECX 中，现要将 a [i] 取到 EAX 相应宽度的寄存器中，则所用的汇编指令是 ()。",
        options: [
            "A. mov 0x80498c0 (,% ecx), % ah",
            "B. mov (0x80498c0,% ecx),% ah",
            "C. mov 0x80498c0 (,% ecx,4),% eax",
            "D. mov (0x80498c0, % ecx,4), % eax"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定全局数组 a 的声明为 double* a [8]，a 的首地址为 0x80498c0，i 在 ECX 中，现要将 a [i] 取到 EAX 相应宽度的寄存器中，则所用的汇编指令是 ()。",
        options: [
            "A. mov 0x80498c0 (,% ecx,4), % eax",
            "B. mov (0x80498c0, % ecx,4), % eax",
            "C. mov 0x80498c0 (,% ecx,8),% eax",
            "D. mov (0x80498c0, % ecx,8), % eax"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定局部 int 型数组 a 的首地址在 EDX 中，i 在 ECX 中，现要将 a [i] 取到 EAX 相应宽度的寄存器中，则所用的汇编指令是 ()。",
        options: [
            "A. mov (% edx, % ecx,2), % ax",
            "B. mov (% edx, % ecx,2), % eax",
            "C. mov (% edx, % ecx,4), % ax",
            "D. mov (% edx, % ecx,4), % eax"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定局部数组 a 的声明为 int a [4]={0,-1,300,20}，a 的首地址为 R [ebp]-16，则在地址 R [ebp]-4 处存放的是 ()。",
        options: [
            "A. 0",
            "B. -1",
            "C. 300",
            "D. 20"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定局部数组 a 的声明为 int a [4]={0,-1,300,20}，a 的首地址为 R [ebp]-16，则将 a 的首地址取到 EDX 的汇编指令是 ()。",
        options: [
            "A. movl -16 (% ebp), % edx",
            "B. movl -16 (% ebp,4), % edx",
            "C. leal -16 (% ebp), % edx",
            "D. leal -16 (% ebp,4), % edx"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "某 C 语言程序中有以下两个变量声明：int a [10]; int*ptr=&a [0]; 则 ptr+i 的值为 ()。",
        options: [
            "A. &a [0]+i",
            "B. &a [0]+2×i",
            "C. &a [0]+4×i",
            "D. &a [0]+8×i"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定 int 型数组 a 的首址在 ECX 中，则 \"a 送 EAX\" 所对应的汇编指令是 ()。",
        options: [
            "A. movl % ecx, % eax",
            "B. movl % edx, % eax",
            "C. leal (% ecx,0), % eax",
            "D. leal (% ecx,4), % eax"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定 int 型数组 a 的首址在 ECX 中，i 在 EDX 中，则 \"&a [i]-a 送 EAX\" 所对应的汇编指令是 ()。",
        options: [
            "A. movl % ecx, % eax",
            "B. movl % edx, % eax",
            "C. leal(,%ecx,4),%eax",
            "D. leal(,%edx,4),%eax"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定 int 型数组 a 的首址在 ECX 中，则 \"&a [4] 送 EAX\" 所对应的汇编指令是 ()。",
        options: [
            "A. movl 4 (% ecx), % eax",
            "B. movl 16 (% ecx), % eax",
            "C. leal 4 (% ecx), % eax",
            "D. leal 16 (% ecx), % eax"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定 int 型数组 a 的首址在 ECX 中，i 在 EDX 中，则 \"*(a+i) 送 EAX\" 所对应的汇编指令是 ()。",
        options: [
            "A. movl (% ecx, % edx,4), % eax",
            "B. movl (% edx, % ecx,4), % eax",
            "C. leal (% ecx, % edx,4), % eax",
            "D. leal (% edx, % ecx,4), % eax"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定 int 型数组 a 的首址在 ECX 中，i 在 EDX 中，则 \"a+i-1 送 EAX\" 所对应的汇编指令是 ()。",
        options: [
            "A. movl -1 (% ecx, % edx,4), % eax",
            "B. movl -4 (% ecx, % edx,4), % eax",
            "C. leal -1 (% ecx, % edx,4), % eax",
            "D. leal -4 (% ecx, % edx,4), % eax"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定静态 short 型二维数组 b 的声明如下：static short b [2][4]={{2,9,-1,5},{3,8,2,-6}}; 若 b 的首地址为 0x8049820，则按行优先存储方式下，数组元素 \"8\" 的地址是 ()。",
        options: [
            "A. 0x8049825",
            "B. 0x804982a",
            "C. 0x8049824",
            "D. 0x8049828"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定静态 short 型二维数组 b 的声明如下：static short b [2][4]={{2,9,-1,5},{3,1,-6,2}}; 若 b 的首地址为 0x8049820，则按行优先存储方式下，地址 0x804982c 中的内容是 ()。",
        options: [
            "A. 0xfa",
            "B. 0xff",
            "C. 0x00",
            "D. 0x05"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定静态 short 型二维数组 b 和指针数组 pb 的声明如下：static short b [2][4]={{2,9,-1,5},{3,1,-6,2}}; static short* pb [2]={b [0],b [1]}; 若 b 的首地址为 0x8049820，则 pb [1] 的值是 ()。",
        options: [
            "A. 0x8049820",
            "B. 0x8049822",
            "C. 0x8049824",
            "D. 0x8049828"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定静态 short 型二维数组 b 和指针数组 pb 的声明如下：static short b [2][4]={{2,9,-1,5},{3,1,-6,2}}; static short* pb [2]={b [0],b [1]}; 若 b 的首地址为 0x8049820，则 & pb [1] 的值是 ()。",
        options: [
            "A. 0x8049830",
            "B. 0x8049832",
            "C. 0x8049834",
            "D. 0x8049838"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定静态 short 型二维数组 b 和指针数组 pb 的声明如下：static short b [2][4]={{2,9,-1,5},{3,1,-6,2}}; static short* pb [2]={b [0],b [1]}; 若 b 和 pb 的首地址分别为 0x8049820、0x8049830，i 在 ECX 中，则 \"*pb [i] 送 EAX\" 所对应的汇编指令序列是 ()。",
        options: [
            "A. movl 0x8049820 (,% ecx,4),% edx; movl (% edx), % eax",
            "B. movl 0x8049820 (,% ecx,4),% edx; leal (% edx),% eax",
            "C. movl 0x8049830 (,% ecx,4),% edx; movl (% edx), % eax",
            "D. movl 0x8049830 (,% ecx,4),% edx; leal (% edx), % eax"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定结构体类型 cont_info 的声明如下：struct cont_info {char id [8]; char name [16]; unsigned post; char address [100]; char phone [20]; }; 若结构体变量 x 初始化定义为 struct cont_info x={\"00000010\",\"ZhangS\",210022,\"273 long street, High Building #3015\",\"12345678\"},x 的首地址在 EDX 中，则 \"unsigned xpost=x.post;\" 所对应的汇编指令为 ()。",
        options: [
            "A. movl 0x24 (% edx), % eax",
            "B. movl 0x18 (% edx), % eax",
            "C. leal 0x24 (% edx), % eax",
            "D. leal 0x18 (% edx), % eax"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定结构体类型 cont_info 的声明如下：struct cont_info {char id [8]; char name [16]; unsigned post; char address [100]; char phone [20]; }; 若变量 x 的数据类型为 struct cont_info，x 的首址在 EDX 中，则 \"unsigned xpost=x.post\" 所对应的汇编指令为 ()。",
        options: [
            "A. movl 0x24 (% edx), % eax",
            "B. movl 0x18 (% edx), % eax",
            "C. leal 0x24 (% edx), % eax",
            "D. leal 0x18 (% edx), % eax"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定结构体类型 cont_info 的声明如下：struct cont_info {unsigned post; char address [125]; char phone [20]; }; 若变量 x 的数据类型为 struct cont_info，x 的首地址为 0x8049820，则字段 x.phone 的起始地址为 ()。",
        options: [
            "A. 0x80498b9",
            "B. 0x80498cd",
            "C. 0x8049973",
            "D. 0x8049993"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定联合体类型 node 的声明如下：union node { struct { int *ptr; int data1; } node1; struct { int data2; union node*next; } node2; }; node 定义了一个单向链表，函数 node_proc 用来处理仅有两个节点的链表，其定义为：void node_proc (union node *np) { np->node2.next->node1.data1=* (np->node2.next->node1.ptr); } 已知参数 np 所在的地址为 R [ebp]+8，则函数 node_proc 中赋值语句对应的汇编代码序列为 ()。",
        options: [
            "A. movl 8 (% ebp),% edx; movl 4 (% edx), % edx; movl (% edx), % ecx; movl (% ecx), % ecx; movl % ecx, 4 (% edx)",
            "B. movl 8 (% ebp), % edx; movl 4 (% edx),% edx; movl (% edx), % ecx; movl (% ecx), % ecx; movl 4 (% edx), % ecx",
            "C. movl 8 (% ebp), % edx; movl 4 (% edx), % edx; movl (% edx), % ecx; movl % ecx, 4 (% edx)",
            "D. movl 8 (% ebp), % edx; movl 4 (% edx), % edx; leal 4 (% edx),% ecx; movl % ecx, 4 (% edx)"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 IA-32 处理器对齐方式的叙述中，错误的是 ()。",
        options: [
            "A. 不同操作系统采用的对齐策略可能不同",
            "B. 可以用编译指导语句 (如 #pragma pack) 设置对齐方式",
            "C. 总是按其数据宽度进行对齐，例如，double 型变量的地址总是 8 的倍数",
            "D. 对于同一个 struct 型变量，在不同对齐方式下可能会占用不同大小的存储区"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关缓冲区溢出以及缓冲区溢出攻击的叙述中，错误的是 ()。",
        options: [
            "A. 当传送到栈中局部数组中的字符的个数超过数组长度时发生缓冲区溢出",
            "B. 恶意程序可利用像 strcpy 等无字符串长度设定的 C 库函数进行缓冲区溢出攻击",
            "C. 只要发生缓冲区溢出，寄存器内容或变量或返回地址等程序信息就可能被修改",
            "D. 只要发生缓冲区溢出，CPU 就会跳转到恶意程序事先设定好的程序去执行"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 IA-32 和 x86-64 之间比较的叙述中，错误的是 ()。",
        options: [
            "A. IA-32 的字长为 32 位，x86-64 的字长为 64 位并兼容 IA-32",
            "B. IA-32 的通用寄存器有 8 个，而 x86-64 的通用寄存器有 16 个",
            "C. IA-32 的通用寄存器为 8/16/32 位，而 x86-64 的通用寄存器为 8/16/32/64 位",
            "D. (unsigned) long 型变量在 IA-32 和 x86-64 中的长度都是 64 位 (四字)"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 x86-64 寄存器的叙述中，错误的是 ()。",
        options: [
            "A. 用来存放将要执行的指令的地址的指令指针寄存器为 64 位的 RIP",
            "B. 基址寄存器和变址寄存器都可以是任意一个 64 位的通用寄存器",
            "C. 任何浮点操作数都被分配在浮点寄存器栈 (ST (0) ~ ST (7)) 中",
            "D. 128 位的 XMM 寄存器从原来 IA-32 中的 8 个增加到 16 个"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 x86-64 对齐方式的叙述中，错误的是 ()。",
        options: [
            "A. short 型数据必须按 2 字节边界对齐",
            "B. int、float 型数据必须按 4 字节边界对齐",
            "C. long、double、指针型数据必须按 8 字节边界对齐",
            "D. long double 型数据在内存占 12 字节空间 (96 位)"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下有关 x86-64 传送指令的叙述中，错误的是 ()。",
        options: [
            "A. 相比 IA-32，增加了 movq 指令，可传送 64 位数据",
            "B. movl 相当于 movzlq，能将目的寄存器高 32 位清 0",
            "C. pushq 和 popq 分别对 ESP 寄存器减 8 和加 8",
            "D. movzbq 的功能是将 8 位寄存器内容零扩展为 64 位"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定变量 x 的类型为 int，对于变量 y 的初始化声明 \"long y=(long) x;\"，其对应的汇编指令是 ()。",
        options: [
            "A. movslq % edx, % rax",
            "B. movzlq % edx, % rax",
            "C. movq % rdx, % rax",
            "D. movl % edx, % eax"
        ],
        answer: "A"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定变量 x 的类型为 long，对于变量 y 的初始化声明 \"int y=(int) x;\"，其对应的汇编指令不可能是 ()。",
        options: [
            "A. movl % edx, % eax",
            "B. movzlq % edx, % rax",
            "C. movslq % edx, % rax",
            "D. movsql % rdx, % eax"
        ],
        answer: "D"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下是 C 语言赋值语句 \"x=a*b+c;\" 对应的 x86-64 汇编代码：movslq % edx, % rdx movsbl % sil, % esi imull % edi, % esi movslq % esi, % rsi leaq (% rdx, % rsi), % rax 已知 x、a、b 和 c 分别在 RAX、RDI、RSI 和 RDX 对应宽度的寄存器中，根据上述汇编指令序列，推测 x、a、b 和 c 的数据类型分别为 ()。",
        options: [
            "A. x-long, a-long,b-char,c-int",
            "B. x-long,a-int,b-char,c-int",
            "C. x-long, a-long, b-char, c-long",
            "D. x-long, a-int, b-char,c-long"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "假定 long 型变量 t、int 型变量 x 和 short 型变量 y 分别在 RAX、RDI 和 RSI 对应宽度的寄存器中，C 语言赋值语句 \"t=(long)(x+y);\" 对应的 x86-64 汇编指令序列不可能是 ()。",
        options: [
            "A. movswl % si, % edx; addl % edi, % edx; movslq % edx, % rax",
            "B. movswq % si, % rax; movslq % edi, % rdx; addq % rdx, % rax",
            "C. movswq % si, % rdx; leaq (% rdx, % rdi), % rax",
            "D. movswq % si, % rsi; movslq % edi, % rdi; leaq (% rsi, % rdi), % rax"
        ],
        answer: "C"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 x86-64 过程调用的叙述中，错误的是 ()。",
        options: [
            "A. 前 6 个参数采用通用寄存器传递，其余参数通过栈传递",
            "B. 在通用寄存器中传递的参数，都存放在 64 位寄存器中",
            "C. 在栈中的参数若是基本类型，则被分配 8 个字节空间",
            "D. 返回参数存放在 RAX 相应宽度的寄存器中"
        ],
        answer: "B"
    },
    {
        chapter: "第三章 程序的转换及机器级表示",
        question: "以下关于 IA-32 和 x86-64 指令系统比较的叙述中，错误的是 ()。",
        options: [
            "A. 对于 64 位数据，x86-64 可用一条指令处理，而 IA-32 需多条指令处理",
            "B. 对于入口参数，x86-64 可用通用寄存器传递，而 IA-32 需用栈来传递",
            "C. 对于浮点操作数，x86-64 存于 128 位的 XMM 中，而 IA-32 存于 80 位的 ST (i) 中",
            "D. 对于返回地址，x86-64 使用通用寄存器保存，而 IA-32 使用栈来保存"
        ],
        answer: "D"
    },
    // 第四章 程序的链接（35题）
    {
        chapter: "第四章 程序的链接",
        question: "以下有关使用 GCC 生成 C 语言程序的可执行文件的叙述中，错误的是 ()。",
        options: [
            "A. 第一步预处理，对 #include、#define、#ifdef 等预处理命令进行处理",
            "B. 第二步编译，将预处理结果编译转换为二进制形式的汇编语言程序代码",
            "C. 第三步汇编，将汇编语言代码汇编转换为机器指令表示的机器语言代码",
            "D. 第四步链接，将多个模块的机器语言代码链接生成可执行目标程序文件"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关使用 GCC 生成 C 语言程序的可执行文件的叙述中，错误的是 ()。",
        options: [
            "A. 预处理的结果还是一个 C 语言源程序文件，属于可读的文本文件",
            "B. 经过预处理、编译和汇编处理的结果是一个可重定位目标文件",
            "C. 每个 C 语言源程序文件生成一个对应的可重定位目标文件",
            "D. 只要在链接命令中指定所有的相关可重定位目标文件，就能生成可执行文件"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关链接所带来的好处和不足的叙述中，错误的是 ()。",
        options: [
            "A. 使得程序员可以分模块开发程序，有利于提高大规模程序的开发效率",
            "B. 使得公共函数库可以为所有程序共享使用，有利于代码重用和提高效率",
            "C. 使得程序员仅需重新编译修改过的源程序模块，从而节省程序开发时间",
            "D. 使得所生成的可执行目标代码中包含了更多公共库函数代码，所占空间大"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 目标文件格式的叙述中，错误的是 ()。",
        options: [
            "A. 可重定位目标文件是 ELF 格式的链接视图，由不同的节组成",
            "B. 可执行目标文件是 ELF 格式的执行视图，由不同的段组成",
            "C. 可重定位和可执行两种目标文件中的数据都是二进制表示的补码形式",
            "D. 可重定位和可执行两种目标文件中的代码都是二进制表示的指令形式"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于链接器基本功能的叙述中，错误的是 ()。",
        options: [
            "A. 将每个符号引用与唯一的一个符号定义进行关联",
            "B. 将每个.o 文件中的.data 节、.text 节和.bss 节分别合并",
            "C. 确定每个符号 (包括全局变量和局部变量) 的首地址",
            "D. 根据所定义符号的首地址对符号的引用进行重定位"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于可重定位目标文件的叙述中，错误的是 ()。",
        options: [
            "A. 在.text 节中包含相应模块内所有机器代码",
            "B. 在.data 节中包含相应模块内所有变量的初始值",
            "C. 在.rodata 节中包含相应模块内所有只读数据",
            "D. 在.rel.text 节和.rel.data 节中包含相应节内所有可重定位信息"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 目标文件的 ELF 头的叙述中，错误的是 ()。",
        options: [
            "A. 包含了 ELF 头本身的长度和目标文件的长度",
            "B. 包含了操作系统版本和机器结构类型等信息",
            "C. 包含了节头表和程序头表各自的起始位置和长度",
            "D. 数据结构在可重定位和可执行两种目标文件中完全一样"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 目标文件的节头表的叙述中，错误的是 ()。",
        options: [
            "A. 每个表项用来记录某个节的内容以及相关描述信息",
            "B. 通过节头表可获得节的名称、类型、起始地址和长度",
            "C. 描述了每个可装入节的起始虚拟地址、对齐和存取方式",
            "D. 数据结构在可重定位和可执行两种目标文件中完全一样"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 可重定位和可执行两种目标文件格式比较的叙述中，错误的是 ()。",
        options: [
            "A. 可重定位目标文件中有可重定位节.rel.text 和.rel.data，在可执行目标文件中则没有",
            "B. 可重定位目标文件中有初始化程序段.init 节，在可执行目标文件中则没有",
            "C. 可执行目标文件中有程序头表 (段头表)，在可重定位目标文件中则没有",
            "D. 可执行目标文件的 ELF 头中有具体程序入口地址，在可重定位目标文件中则为 0"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于 ELF 可执行目标文件的程序头表 (段头表) 的叙述中，错误的是 ()。",
        options: [
            "A. 用于描述可执行文件中的节与主存储器中的存储段之间的映射关系",
            "B. 通过段头表可获得可装入段或特殊段的类型、在文件中的偏移位置及长度",
            "C. 描述了每个可装入段的起始虚拟地址、存储长度、存取方式和对齐方式",
            "D. .text 节和.rodata 节都包含在只读代码段，而.data 节和.bss 节都包含在读写数据段"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下关于链接过程中对符号定义的判断中，错误的是 ()。",
        options: [
            "A. 全局变量声明 \"int x, y ;\" 中，x 和 y 都是符号的定义",
            "B. 全局变量声明 \"int* xp=&x;\" 中，xp 和 x 都是符号的定义",
            "C. 静态局部变量声明 \"static int x=*xp ;\" 中，x 是符号的定义",
            "D. 函数内的局部变量声明 \"short x=200 ;\" 中，x 不是符号的定义"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "若 x 为局部变量，xp、y 和 z 是全局变量，则以下判断中错误的是 ()。",
        options: [
            "A. 赋值语句 \"int y=x+z ;\" 中，y 和 z 都是符号的引用",
            "B. 赋值语句 \"y=x+z ;\" 中，y 和 z 都是符号的引用",
            "C. 静态局部变量声明 \"static int x=*xp ;\" 中，xp 是符号的引用",
            "D. 赋值语句 \"y=x+*xp ;\" 中，y 和 xp 都是符号的引用"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关链接符号类型的叙述中，错误的是 ()。",
        options: [
            "A. 由模块 m 定义并能被其他模块引用的符号称为 m 的全局符号",
            "B. 由其他模块定义并被模块 m 引用的符号称为 m 的外部符号",
            "C. 由模块 m 定义并仅在 m 中引用的符号称为 m 的本地符号",
            "D. 在模块 m 内的某个函数中定义的局部变量称为 m 的局部符号"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关 ELF 目标文件的符号表的叙述中，错误的是 ()。",
        options: [
            "A. 可重定位和可执行两种目标文件中都有符号表且数据结构一样",
            "B. 符号表定义在.symtab 节中，每个表项描述某个符号的相应信息",
            "C. 通过符号表可获得符号的名称、所在节及在节中偏移地址和长度",
            "D. 符号表中包含了所有定义符号的描述信息，包括局部变量的相关信息"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是有关链接过程中符号解析 (符号绑定) 的叙述，错误的是 ()。",
        options: [
            "A. 符号解析的目的是将符号引用与某目标模块中定义的符号建立关联",
            "B. 同一个符号名可能在多个模块中有定义，每个定义处的符号都须分配空间",
            "C. 本地符号的解析比较简单，只要与本模块内定义的符号关联即可",
            "D. 全局符号 (包括外部符号) 需将模块内的引用与模块外的定义符号绑定"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关强符号和弱符号定义的叙述中，错误的是 ()。",
        options: [
            "A. 局部符号没有强、弱符号的概念",
            "B. 所有出现的函数名都是强符号",
            "C. 没有初始化的全局变量名是弱符号",
            "D. 已初始化的全局变量名是强符号"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关强符号和弱符号的符号解析的叙述中，错误的是 ()。",
        options: [
            "A. 一个符号名只能有一个强符号，否则符号解析失败",
            "B. 一个符号名可以有多个弱符号，任选一个为其定义",
            "C. 一个符号名可以有一个强符号和多个弱符号，强符号为其定义",
            "D. 一个符号名可以仅出现在引用处或仅出现在定义处"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/*m1.c*/ int p(void); int main() { int p1=p(); return p1; } /*m2.c*/ static int main=1; int p () { main++; return main; } 对于上述两个源程序文件链接时的符号解析，错误的是 ()。",
        options: [
            "A. 在 m1 中，定义了一个强符号 main 和一个弱符号 p",
            "B. 在 m2 中，定义了一个强符号 p 和一个本地符号 main",
            "C. 在 m1 中，对 m2 中定义的强符号 p 的引用只有一处",
            "D. 因为出现了两个强符号 main，所以会发生链接错误"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/*m1.c*/ int p(void); int main() { int p1=p(); return p1; } /*m2.c*/ int main=1; int p () { int p1=main++; return main; } 对于上述两个源程序文件链接时的符号解析，错误的是 ()。",
        options: [
            "A. 在 m1 中，定义了一个强符号 main 和一个弱符号 p",
            "B. 在 m2 中，定义了一个强符号 p 和一个强符号 main",
            "C. 在模块 m1 的所有语句中，对符号 p1 的引用共有两处",
            "D. 因为出现了两个强符号 main，所以会发生链接错误"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/*m1.c*/ int x=100; int p1(void); int main() { x=p1(); return x; } /*m2.c*/ float x; static main=1; int p1 () { int p1=main+(int) x; return p1; } 对于上述两个源程序文件链接时的符号解析，错误的是 ()。",
        options: [
            "A. m1 中对 x 的两处引用都与 m1 中对 x 的定义绑定",
            "B. m2 中对 x 的引用与 m2 中对 x 的定义绑定",
            "C. m2 中的变量 p1 与函数 p1 被分配在不同存储区",
            "D. 虽然 x、main 和 p1 都出现了多次定义，但不会发生链接错误"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是两个源程序文件：/*m1.c*/ int x=100; short y=1,z=2; int main() { p1(); printf(\"x=%d,z=%d\\n\",x,z); } /*m2.c*/ double x; void p1 () { x=-1.0; } 上述程序执行的结果是 ()。(提示：1074790400=2³⁰+2²⁰，16400=2¹⁴+2⁴)",
        options: [
            "A. x=100, z=2",
            "B. x=-1, z=2",
            "C. x=-1074790400, z=0",
            "D. x=0, z=-16400"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假设调用关系如下：func.o→libx.a 和 liby.a 中的函数，libx.a→libz.a 中的函数，libx.a 和 liby.a 之间、liby.a 和 libz.a 相互独立，则以下几个命令行中，静态链接发生错误的命令是 ()。",
        options: [
            "A. gcc -static -o myfunc func.o libx.a liby.a libz.a",
            "B. gcc -static -o myfunc func.o liby.a libz.a libx.a",
            "C. gcc -static -o myfunc func.o libx.a libz.a liby.a",
            "D. gcc -static -o myfunc func.o liby.a libx.a libz.a"
        ],
        answer: "B"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假设调用关系如下：func1.o→func2.o，func1.o→libx.a 中的函数，func2.o→libx.a 中的函数，libx.a→liby.a 同时 liby.a→libx.a，则以下命令行中，能够正确进行静态链接的命令是 ()。",
        options: [
            "A. gcc -static -o myfunc func1.o func2.o libx.a liby.a libx.a",
            "B. gcc -static -o myfunc func2.o func1.o liby.a libx.a liby.a",
            "C. gcc -static -o myfunc libx.a liby.a libx.a func1.o func2.o",
            "D. gcc -static -o myfunc liby.a libx.a liby.a func1.o func2.o"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关重定位功能的叙述中，错误的是 ()。",
        options: [
            "A. 重定位的最终目标是重新确定各模块合并后每个引用所指向的目标地址",
            "B. 重定位的第一步应先将相同的节合并，且将具有相同存取属性的节合并成段",
            "C. 重定位的第二步是确定每个段的起始地址，并确定段内每个定义处符号的地址",
            "D. 重定位的最后一步是将引用处的地址修改为与之关联 (绑定) 的定义处的首地址"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关重定位信息的叙述中，错误的是 ()。",
        options: [
            "A. 重定位信息是由编译器在生成汇编指令时产生的",
            "B. 指令中的重定位信息在可重定位目标文件的.rel.text 节中",
            "C. 数据中的重定位信息在可重定位目标文件的.rel.data 节中",
            "D. 重定位信息包含需要重定位的位置、绑定的符号和重定位类型"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关 IA-32 的重定位类型的叙述中，错误的是 ()。",
        options: [
            "A. 基本重定位类型有绝对地址和 PC 相对地址两种方式",
            "B. 对于过程调用中的引用，通常在 CALL 指令中采用 PC 相对地址方式",
            "C. PC 相对地址指引用所绑定符号的地址与当前 PC 的相对地址是重定位值",
            "D. 过程调用相关的重定位中，PC 相对地址中使用的当前 PC 是指 CALL 指令的地址"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假定 \"int buf [2]={10,50};\" 所定义的 buf 被分配在静态数据区，其首地址为 0x8048930，bufp1 为全局变量，被分配在 buf 随后的存储空间。以下关于 \"int*bufp1=&buf [1];\" 的重定位的描述中，错误的是 ()。",
        options: [
            "A. bufp1 的地址为 0x8048938，重定位前的内容为 04H、00H、00H、00H",
            "B. 在可重定位目标文件的.rel.data 节中，有一个引用 buf 的重定位条目",
            "C. 在相应的重定位条目中，对 bufp1 和 buf 的引用均采用绝对地址方式",
            "D. 在可执行目标文件中，地址 0x8048938 开始的 4 个字节为 34H、89H、04H、08H"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "假定 \"int buf [2]={10,50};\" 所定义的 buf 被分配在静态数据区，其首地址为 0x8048930，bufp1 为全局变量，也被分配在静态数据区。以下关于 \"bufp1=&buf [1];\" 的重定位的描述中，错误的是 ()。",
        options: [
            "A. 在可重定位目标文件的.rel.data 节中，有一个与 bufp1 相关的重定位条目",
            "B. 在可重定位目标文件的.rel.text 节中，有一个与 buf 相关的重定位条目",
            "C. 在相应的重定位条目中，对 bufp1 和 buf 的引用均采用绝对地址方式",
            "D. 可用一条 mov 指令实现该赋值语句，该 mov 指令中有两处需要重定位"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关在 Linux 系统中启动可执行目标文件执行的叙述中，错误的是 ()。",
        options: [
            "A. 可在 GUI (命令行用户界面) 中双击可执行目标文件对应的图标来启动其执行",
            "B. 可在 GUI (命令行用户界面) 中的命令行提示符后输入对应的命令来启动其执行",
            "C. 可以通过在一个程序中调用 execve () 系统调用函数来启动可执行文件执行",
            "D. 不管是哪种启动执行方式，最终都是通过调用 execve () 系统调用函数实现的"
        ],
        answer: "A"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关在 Linux 系统中加载可执行目标文件的叙述中，错误的是 ()。",
        options: [
            "A. 可执行目标文件的加载通过 execve () 函数调用的加载器来完成",
            "B. 加载器通过可执行目标文件中的程序头表对可装入段进行加载",
            "C. 在可执行目标文件的加载过程中，其中的指令和数据被读入主存储器",
            "D. 任何可执行目标文件中的可装入段被映射到一个统一的虚拟地址空间"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下是在 Linux 系统中启动并加载可执行目标文件过程中 shell 命令行解释程序所做的部分操作：①构造 argv 和 envp ②调用 fork () 系统调用函数 ③调用 execve () 系统调用函数 ④读入命令 (可执行文件名) 及参数 启动并加载可执行目标文件的正确步骤是 ()。",
        options: [
            "A. ①→②→③→④",
            "B. ②→④→①→③",
            "C. ④→①→②→③",
            "D. ④→①→③→②"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关动态链接及其所链接的共享库以及动态链接生成的可执行目标文件的叙述中，错误的是 ()。",
        options: [
            "A. 共享库在 Linux 下称为动态共享对象 (.so)，在 Windows 下称为动态链接库 (.dll)",
            "B. 生成的可执行目标文件是部分链接的，也即其中还有部分引用没有进行重定位",
            "C. 可执行目标文件由动态链接器对可重定位目标文件和共享库中部分信息进行链接而成",
            "D. 可执行目标文件在加载或执行时，系统将会调出动态链接器利用共享库对其进行动态链接"
        ],
        answer: "C"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关静态链接和动态链接比较的叙述中，错误的是 ()。",
        options: [
            "A. 静态库函数代码包含在进程代码段中，而共享库函数代码不包含在进程代码段中",
            "B. 静态库函数代码包含在可执行目标文件中，而共享库函数代码不包含在可执行目标文件中",
            "C. 静态库函数更新后需对程序重新编译和链接，而共享库函数更新后程序无需重新编译和链接",
            "D. 静态库函数在加载时被链接，而共享库函数可在加载或运行时被链接"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "以下有关动态链接所用共享库代码的叙述中，错误的是 ()。",
        options: [
            "A. 共享库代码一定是位置无关代码 (PIC)",
            "B. 用 GCC 生成共享库文件时应使用 -PIC 选项",
            "C. 链接器可将共享库代码映射到不同的地址运行",
            "D. 共享库代码长度发生变化时会影响调用它的程序"
        ],
        answer: "D"
    },
    {
        chapter: "第四章 程序的链接",
        question: "一个共享库文件 (.so 文件) 由多个模块 (.o 文件) 生成。在生成共享库文件的过程中，需要对.o 文件进行处理，以生成位置无关代码。以下有关位置无关代码 (PIC) 生成的叙述中，错误的是 ()。",
        options: [
            "A. 模块内函数之间的调用可用 PC 相对地址实现，无需动态链接器进行重定位",
            "B. 模块内数据的引用无需动态链接器进行重定位，因为引用与定义间相对位置固定",
            "C. 模块外数据的引用需要动态链接器进行重定位，重定位时在 GOT 中填入外部数据的地址",
            "D. 模块间函数调用需要动态链接器进行重定位，重定位时在 GOT 和 PLT 中填入相应内容"
        ],
        answer: "D"
    },
    // 第五章 程序的执行（18题）
    {
        chapter: "第五章 程序的执行",
        question: "计算机中的核心时序信号是 ()。",
        options: [
            "A. CPU 时钟周期",
            "B. 主板时钟周期",
            "C. 指令周期",
            "D. 存储周期"
        ],
        answer: "A"
    },
    {
        chapter: "第五章 程序的执行",
        question: "CPU 中控制器的功能是 ()。",
        options: [
            "A. 产生时序信号",
            "B. 控制从主存取出一条指令",
            "C. 完成指令操作码译码",
            "D. 完成指令操作码译码，并产生操作控制信号"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "冯・诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU 依据 () 来区分它们。",
        options: [
            "A. 指令和数据的表示形式不同",
            "B. 指令和数据的寻址方式不同",
            "C. 指令和数据的访问时点不同",
            "D. 指令和数据的地址形式不同"
        ],
        answer: "C"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列寄存器中，对汇编语言程序员不透明的是 ()。",
        options: [
            "A. 存储器地址寄存器 MAR",
            "B. 程序计数器 PC",
            "C. 存储器数据寄存器 MDR",
            "D. 指令寄存器 IR"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关 CPU 中部分部件的功能的描述中，错误的是 ()。",
        options: [
            "A. 控制单元用于对指令操作码译码并生成控制信号",
            "B. PC 称为程序计数器，用于存放将要执行的指令的地址",
            "C. 通过将 PC 按当前指令长度增量，可实现指令的按序执行",
            "D. IR 称为指令寄存器，用来存放当前指令的操作码"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "执行完当前指令后，PC 中存放的是后继指令的地址，因此 PC 的位数和 () 的位数相同。",
        options: [
            "A. 指令寄存器 IR",
            "B. 指令译码器 ID",
            "C. 存储器地址寄存器 MAR",
            "D. 程序状态字寄存器 PSWR"
        ],
        answer: "C"
    },
    {
        chapter: "第五章 程序的执行",
        question: "通常情况下，下列 () 部件不包含在中央处理器 (CPU) 芯片中。",
        options: [
            "A. ALU",
            "B. 控制器",
            "C. 通用寄存器",
            "D. DRAM"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关程序计数器 PC 的叙述中，错误的是 ()。",
        options: [
            "A. 每条指令执行后，PC 的值都会被改变",
            "B. 指令顺序执行时，PC 的值总是自动加 1",
            "C. 调用指令执行后，PC 的值一定是被调用过程的入口地址",
            "D. 无条件转移指令执行后，PC 的值一定是转移目标地址"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "CPU 取出一条指令并执行所用的时间被称为 ()。",
        options: [
            "A. 时钟周期",
            "B. CPU 周期",
            "C. 机器周期",
            "D. 指令周期"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关指令周期的叙述中，错误的是 ()。",
        options: [
            "A. 指令周期的第一个阶段一定是取指令阶段",
            "B. 乘法指令和加法指令的指令周期总是一样长",
            "C. 一个指令周期由若干个机器周期或时钟周期组成",
            "D. 相对于 RISC，CISC 风格处理器的指令周期更长"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关 CPU 时钟信号的叙述中，错误的是 ()。",
        options: [
            "A. 处理器总是每来一个时钟信号就开始执行一条新的指令",
            "B. 边沿触发指状态单元总在时钟上升沿或下降沿开始改变状态",
            "C. 时钟周期以相邻状态单元之间最长组合逻辑延迟为基准确定",
            "D. 每个时钟周期称为一个节拍，机器的主频就是时钟周期的倒数"
        ],
        answer: "A"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关数据通路的叙述中，错误的是 ()。",
        options: [
            "A. 数据通路由若干操作元件和状态元件连接而成",
            "B. 数据通路的功能由控制部件送出的控制信号决定",
            "C. ALU 属于操作元件，用于执行各类算术和逻辑运算",
            "D. 通用寄存器属于状态元件，但不包含在数据通路中"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "以下关于指令流水线设计的叙述中，错误的是 ()。",
        options: [
            "A. 指令执行过程中的各个子功能都须包含在某个流水段中",
            "B. 所有子功能都必须按一定的顺序经过流水段",
            "C. 虽然各子功能所用实际时间可能不同，但经过每个流水段的时间都一样",
            "D. 任何时候各个流水段的功能部件都不可能执行空 (nop) 操作"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "下列有关 RISC 特征的描述中，错误的是 ()。",
        options: [
            "A. 指令格式规整，寻址方式少",
            "B. 采用硬连线控制和指令流水线",
            "C. 配置的通用寄存器数目不多",
            "D. 运算类指令的操作数不访存"
        ],
        answer: "C"
    },
    {
        chapter: "第五章 程序的执行",
        question: "以下关于指令流水线和指令执行效率关系的叙述中，错误的是 ()。",
        options: [
            "A. 加倍增加流水段个数不能成倍提高指令执行效率",
            "B. 为了提高指令吞吐率，流水段个数可以无限制地增多",
            "C. 加深流水线深度，可以提高处理器的时钟频率",
            "D. 随着流水段个数的增加，流水段之间缓存开销的比例增大"
        ],
        answer: "B"
    },
    {
        chapter: "第五章 程序的执行",
        question: "某计算机的指令流水线由 4 个功能段组成，指令流经各功能段的时间 (忽略各功能段之间流水段寄存器的缓存时间) 分别为 90ns、80ns、70ns 和 60ns，则该计算机的 CPU 时钟周期至少是 ()。",
        options: [
            "A. 90ns",
            "B. 80ns",
            "C. 70ns",
            "D. 60ns"
        ],
        answer: "A"
    },
    {
        chapter: "第五章 程序的执行",
        question: "假定执行最复杂的指令需要完成 6 个子功能，分别由对应的功能部件 A~F 来完成，每个功能部件所花的时间分别为 80ps、40ps、50ps、70ps、20ps、30ps，流水段寄存器延时为 20ps，现把最后两个功能部件 E 和 F 合并，以产生一个 5 段流水线。该 5 段流水线的时钟周期至少是 () ps。",
        options: [
            "A. 70",
            "B. 80",
            "C. 90",
            "D. 100"
        ],
        answer: "D"
    },
    {
        chapter: "第五章 程序的执行",
        question: "以下给定的说法中，不会引起指令流水线阻塞的是 ()。",
        options: [
            "A. 外部中断",
            "B. 指令数据相关",
            "C. 执行空操作指令",
            "D. 条件转移"
        ],
        answer: "C"
    },
    // 第六章 层次结构存储系统（43题）
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面有关半导体存储器组织的叙述中，错误的是 ()。",
        options: [
            "A. 存储器的核心部分是存储阵列，由若干存储单元构成",
            "B. 存储单元由若干个存放 0 或 1 的存储元件构成",
            "C. 一个存储单元有一个编号，就是存储单元的地址",
            "D. 同一个存储器中，每个存储单元的宽度可以不同"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面 4 种存储器中，目前已被淘汰的是 ()。",
        options: [
            "A. 半导体存储器",
            "B. 磁表面存储器",
            "C. 磁芯存储器",
            "D. 光盘存储器"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "若计算机的主存储器容量为 1GB，也就等于 ()。",
        options: [
            "A. 2³⁰个字节",
            "B. 10³⁰个字节",
            "C. 2¹⁰个字节",
            "D. 10⁹个字节"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "某 SRAM 芯片的容量为 1024x4 位，则地址和数据引脚的数目分别为 ()。",
        options: [
            "A. 10，4",
            "B. 5，4",
            "C. 10，8",
            "D. 5，8"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "某计算机字长 16 位，主存地址空间大小是 64KB，按字节编址，则寻址范围是 ()。",
        options: [
            "A. 0 ~(64K-1)",
            "B. 0 ~(32K-1)",
            "C. 0 ~(64KB-1)",
            "D. 0 ~(32KB-1)"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下选项中，属于可擦除可编程只读存储器的是 ()。",
        options: [
            "A. 读写存储器",
            "B. 掩膜只读存储器",
            "C. 可编程的只读存储器",
            "D. 可擦除可编程的只读存储器"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下列几种存储器中，() 是易失性存储器。",
        options: [
            "A. cache",
            "B. EPROM",
            "C. Flash Memory",
            "D. CD-ROM"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址空间大小为 1024MB，按字节编址，每次读写操作最多可以一次存取 32 位。不考虑其他因素，则存储器地址寄存器 MAR 和存储器数据寄存器 MDR 的位数至少应分别为 ()。",
        options: [
            "A. 30，8",
            "B. 30，32",
            "C. 28，8",
            "D. 28，32"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "需要定时刷新的半导体存储器芯片是 ()。",
        options: [
            "A. SRAM",
            "B. DRAM",
            "C. EPROM",
            "D. Flash Memory"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "通常采用行、列地址引脚复用的半导体存储器芯片是 ()。",
        options: [
            "A. SRAM",
            "B. DRAM",
            "C. EPROM",
            "D. Flash Memory"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "具有 RAS (行地址选通) 和 CAS (列地址选通) 信号引脚的半导体存储器芯片是 ()。",
        options: [
            "A. SRAM",
            "B. DRAM",
            "C. EPROM",
            "D. Flash Memory"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面有关 ROM 和 RAM 的叙述中，错误的是 ()。",
        options: [
            "A. RAM 是可读可写存储器，ROM 是只读存储器",
            "B. ROM 和 RAM 都采用随机访问方式进行读写",
            "C. 系统的主存由 RAM 和 ROM 组成",
            "D. 系统的主存都用 DRAM 芯片实现"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下面有关半导体存储器的叙述中，错误的是 ()。",
        options: [
            "A. 半导体存储器都采用随机存取方式进行读写",
            "B. ROM 芯片属于半导体随机存储器芯片",
            "C. SRAM 是半导体静态随机访问存储器，可用作 cache",
            "D. DRAM 是半导体动态随机访问存储器，可用作主存"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定 DDR3 SDRAM 芯片内部核心频率为 133.25MHz，与之相连的存储器总线每次传输 8 字节，则下面有关叙述中，错误的是 ()。",
        options: [
            "A. 芯片内部 I/O 缓冲采用 8 位预取技术",
            "B. 存储器总线每秒传 1066M 次数据",
            "C. 存储器总线的时钟频率为 1066MHz",
            "D. 存储器总线的带宽大约为 8.5GB/s"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定用若干个 16Kx1 位的存储器芯片组成一个 64Kx8 位的存储器，芯片内各单元连续编址，则地址为 8000H 所在的芯片的最小地址为 ()。",
        options: [
            "A. 4000H",
            "B. 6000H",
            "C. 8000H",
            "D. A000H"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定用若干个 16Kx8 位的存储器芯片组成一个 64Kx8 位的存储器，芯片各单元交叉编址，则地址 BFFFH 所在的芯片的最小地址为 ()。",
        options: [
            "A. 0000H",
            "B. 0001H",
            "C. 0002H",
            "D. 0003H"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "用存储容量为 16Kx1 位的存储器芯片组成一个 64Kx8 位的存储器，则在字方向和位方向上分别扩展了 () 倍。",
        options: [
            "A. 4 和 2",
            "B. 4 和 8",
            "C. 2 和 4",
            "D. 8 和 4"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "存储容量为 16Kx4 位的 DRAM 芯片，其地址引脚和数据引脚数各是 ()。",
        options: [
            "A. 7 和 1",
            "B. 7 和 4",
            "C. 14 和 1",
            "D. 14 和 4"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "多模块存储器之所以能高速进行读 / 写，是因为 ()。",
        options: [
            "A. 采用了高速元器件",
            "B. 各模块有独立的读写电路",
            "C. 采用了信息预读技术",
            "D. 模块内各单元地址连续"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "相联存储器是按 () 进行寻址访问的存储器。",
        options: [
            "A. 地址指定方式",
            "B. 内容指定方式",
            "C. 堆栈访问方式",
            "D. 队列访问方式"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下是有关磁盘驱动器的叙述，其中错误的是 ()。",
        options: [
            "A. 送到磁盘驱动器的盘地址由磁头号、盘面号和扇区号组成",
            "B. 能控制磁头移动到指定磁道，并发回 \"寻道结束\" 信号",
            "C. 能控制磁盘片转过指定的扇区，并发回 \"扇区符合\" 信号",
            "D. 能对指定盘面的指定扇区进行数据的读或写操作"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定一个磁盘存储器有 4 个盘片，用于记录信息的柱面数为 2000，每个磁道上有 3000 个扇区，每个扇区 512B，则该磁盘存储器的容量约为 ()。",
        options: [
            "A. 12MB",
            "B. 24MB",
            "C. 12GB",
            "D. 24GB"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定一个磁盘的转速为 7200RPM，磁盘的平均寻道时间为 20ms，平均数据传输率为 1MB/s，不考虑排队等待时间，那么读一个 512 字节的扇区的平均时间大约为 ()。",
        options: [
            "A. 14.7ms",
            "B. 18.8ms",
            "C. 24.7ms",
            "D. 28.8ms"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "在存储器分层体系结构中，存储器速度从最快到最慢的排列顺序是 ()。",
        options: [
            "A. 寄存器 - 主存 - cache - 辅存",
            "B. 寄存器 - 主存 - 辅存 - cache",
            "C. 寄存器 - cache - 辅存 - 主存",
            "D. 寄存器 - cache - 主存 - 辅存"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "在存储器分层体系结构中，存储器从容量最大到最小的排列顺序是 ()。",
        options: [
            "A. 主存 - 辅存 - cache - 寄存器",
            "B. 辅存 - cache - 主存 - 寄存器",
            "C. 辅存 - 主存 - cache - 寄存器",
            "D. 辅存 - 主存 -- 寄存器 -- cache"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "在主存和 CPU 之间增加 cache 的目的是 ()。",
        options: [
            "A. 增加内存容量",
            "B. 提高内存可靠性",
            "C. 加快信息访问速度",
            "D. 增加内存容量，同时加快访问速度"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下哪一种情况能很好地发挥 cache 的作用？()。",
        options: [
            "A. 程序中不含有过多的 I/O 操作",
            "B. 程序的大小不超过实际的内存容量",
            "C. 程序具有较好的访问局部性",
            "D. 程序的指令间相关度不高"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址位数为 32 位，按字节编址，主存和 cache 之间采用直接映射方式，主存块大小为 1 个字，每字 32 位，写操作时采用直写 (write through) 方式，则能存放 32K 字数据的 cache 的总容量至少应有多少位？()。",
        options: [
            "A. 1504K",
            "B. 1536K",
            "C. 1568K",
            "D. 1600K"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址位数为 32 位，按字节编址，主存和 cache 之间采用直接映射方式，主存块大小为 1 个字，每字 32 位，写操作时采用回写 (write back) 方式，则能存放 32K 字数据的 cache 的总容量至少应有多少位？()。",
        options: [
            "A. 1504K",
            "B. 1536K",
            "C. 1568K",
            "D. 1600K"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存地址位数为 32 位，按字节编址，主存和 cache 之间采用全相联映射方式，主存块大小为 1 个字，每字 32 位，采用回写 (write back) 方式和随机替换策略，则能存放 32K 字数据的 cache 的总容量至少应有多少位？()。",
        options: [
            "A. 1536K",
            "B. 1568K",
            "C. 2016K",
            "D. 2048K"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存按字节编址，cache 共有 64 行，采用直接映射方式，主存块大小为 32 字节，所有编号都从 0 开始。问主存第 2593 号单元所在主存块对应的 cache 行号是 ()。",
        options: [
            "A. 1",
            "B. 17",
            "C. 34",
            "D. 81"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定主存按字节编址，cache 共有 64 行，采用 4 路组相联映射方式，主存块大小为 32 字节，所有编号都从 0 开始。问主存第 2593 号单元所在主存块对应的 cache 组号是 ()。",
        options: [
            "A. 1",
            "B. 17",
            "C. 34",
            "D. 81"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需 1 个时钟周期，存储器准备一个数据需 8 个时钟周期，总线上每传送 1 个数据需 1 个时钟周期。若主存和 cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 4B，则 cache 的一次缺失损失至少为多少个时钟周期？()。",
        options: [
            "A. 64",
            "B. 72",
            "C. 80",
            "D. 160"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定 CPU 通过存储器总线读取数据的过程为：发送地址和读命令需 1 个时钟周期，存储器准备一个数据需 8 个时钟周期，总线上每传送 1 个数据需 1 个时钟周期。若主存和 cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 cache 的一次缺失损失至少为多少个时钟周期？()。",
        options: [
            "A. 64",
            "B. 72",
            "C. 80",
            "D. 160"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "假定采用多模块交叉存储器组织方式，存储器芯片和总线支持突发传送，CPU 通过存储器总线读取数据的过程为：发送首地址和读命令需 1 个时钟周期，存储器准备第一个数据需 8 个时钟周期 (即 CAS 潜伏期 = 8)，随后每个时钟周期总线上传送 1 个数据，可连续传送 8 个数据 (即突发长度 = 8)。若主存和 cache 之间交换的主存块大小为 64B，存取宽度和总线宽度都为 8B，则 cache 的一次缺失损失至少为多少个时钟周期？()。",
        options: [
            "A. 17",
            "B. 20",
            "C. 33",
            "D. 65"
        ],
        answer: "A"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下是有关虚拟存储管理机制中地址转换的叙述，其中错误的是 ()。",
        options: [
            "A. 地址转换是指把逻辑地址转换为物理地址",
            "B. 通常逻辑地址的位数比物理地址的位数少",
            "C. 地址转换过程中会发现是否 \"缺页\"",
            "D. MMU 在地址转换过程中要访问页表项"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "下列命中组合情况中，一次访存过程中不可能发生的是 ()。",
        options: [
            "A. TLB 命中、cache 命中、page 命中",
            "B. TLB 未命中、cache 命中、page 命中",
            "C. TLB 未命中、cache 未命中、page 命中",
            "D. TLB 未命中、cache 命中、page 未命中"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下是有关虚拟存储管理机制中页表的叙述，其中错误的是 ()。",
        options: [
            "A. 系统中每个进程有一个页表",
            "B. 页表中每个表项与一个虚页对应",
            "C. 每个页表项中都包含装入位 (有效位)",
            "D. 所有进程都可以访问页表"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关缺页处理的叙述中，错误的是 ()。",
        options: [
            "A. 若对应页表项中的有效位为 0，则发生缺页",
            "B. 缺页是一种外部中断，需要调用操作系统提供的中断服务程序来处理",
            "C. 缺页处理过程中需根据页表中给出的磁盘地址去读磁盘数据",
            "D. 缺页处理完后要重新执行发生缺页的指令"
        ],
        answer: "B"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关页式存储管理的叙述中，错误的是 ()。",
        options: [
            "A. 进程地址空间被划分成等长的页，内存被划分成同样大小的页框",
            "B. 采用全相联映射，每个页可以映射到任何一个空闲的页框中",
            "C. 当从磁盘装入的信息不足一页时会产生页内碎片",
            "D. 相对于段式存储管理，分页式更有利于保护"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关段式存储管理的叙述中，错误的是 ()。",
        options: [
            "A. 段是逻辑结构上相对独立的程序块，因此段是可变长的",
            "B. 按程序中实际的段来分配主存，所以分配后的存储块是可变长的",
            "C. 每个段表项必须记录对应段在主存的起始位置和段的长度",
            "D. 分段方式对低级语言程序员和编译器来说是透明的"
        ],
        answer: "D"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下有关快表的叙述中，错误的是 ()。",
        options: [
            "A. 快表的英文缩写是 TLB，称为转换后援缓冲器",
            "B. 快表中存放的是当前进程的常用页表项",
            "C. 在快表中命中时，在 L1 cache 中一定命中",
            "D. 快表是一种高速缓存，一定在 CPU 中"
        ],
        answer: "C"
    },
    {
        chapter: "第六章 层次结构存储系统",
        question: "以下给出的事件中，无需异常处理程序进行处理的是 ()。",
        options: [
            "A. 缺页故障",
            "B. cache 缺失",
            "C. 地址越界",
            "D. 除数为 0"
        ],
        answer: "B"
    }
];














